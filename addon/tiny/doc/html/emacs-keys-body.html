<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN"
  "http://www.w3.org/TR/REC-html40/frameset.dtd">
<HTML>
<!--
        See unix what(1) and ident(1) why those funny tags
        @(#) Document: 
        @(#) Contact :  jari.aalto@poboxes.com
        The LINK tags are used by advanced browsers. The BASE signifies
        true location of the original document, and mirrored site
        location. It is where the #TAG go when you define them.
-->
<HEAD>
<TITLE>
No title
</TITLE>



<!--    ......................................................................
    META TAGS (FOR SEARCH ENGINES)
    ......................................................................
-->


  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=utf-8">

  <META HTTP-EQUIV="Expires" CONTENT="Fri,  4 Oct 2002 01:24:00 GMT">


  <META HTTP-EQUIV="Made"
	CONTENT="mailto:jari.aalto@poboxes.com">


  <META NAME="Generator"
	CONTENT="2002-08-05 04:24 Perl 5 program t2html.pl v2002.0805 available at http://cpan.perl.org/modules/by-authors/id/J/JA/JARIAALTO/">



<!--    ......................................................................
    BUTTON DEFINITION START
    ......................................................................
-->


    <STYLE TYPE="text/css">


        /*

	    ///////////////////////////////////////////////////////////
               NOTE    NOTE    NOTE    NOTE    NOTE    NOTE    NOTE

            This is the default CSS 2.0 generated by the program,
            please see "t2html.pl --help" for option --script-file
            to import your own CSS and Java definitions into the page.

            XHTML note: at page http://www.w3.org/TR/xhtml1/#guidelines
            It is recommended that CSS2 with XHTML use lowercase
            element and attribute names

	    This default CSS2 has been validated according to
	    http://jigsaw.w3.org/css-validator/validator-uri.html.en

	    To design colors, visit:
	    http://www.btexact.com/people/rigdence/colours/

               NOTE    NOTE    NOTE    NOTE    NOTE    NOTE    NOTE
	    ///////////////////////////////////////////////////////////

            Comments on the CSS tags:

            -   block-width: "thin" (Netscape ok, MSIE nok)

            NETSCAPE 4.05

            -  In general does not render CSS very well. Eg
               font size changes does not show up in screen.
            -  :hover property is not recognised

            NETSCAPE 4.75 as of 2000-10-01

            -  Shows garbage for stylesheet section that marked CITATION.
               (IE has no trouble to show it)

            MSIE 4.0+

            - Renders CSS very well.

            Media types

            - Netscape does not transfer the CSS element definitions to
              the "print" media as it should. They only affect Browser
              or media "screen"
            - That is why you really have to say EM STRONG ... /STRONG EM
              to get that kind of text seen in printer too. You cannot
              just define P.column7 { ... }

            The @media CSS definition is not supported by Netscape 4.05
            I do not know if MSIE 4.0 supports it.

            So doing this would cause CSS to be ignored completely
            (never mind that CSS says the default CSS applies to "visual",
            which means both print and scree types.)

                @media print, screen {  P.code {..}  }

            To work around that, we separate the definitions with

                P.code { .. }               // For screen

                @media print { P.code      // for printer
                {
                    ..
                }}

            And wish that some newer browser will render it right.

        */


        /*   ////////////////////////// Make pointing AHREF more visual */

        body
        {
            font-family: "Times New Roman", serif;
            

            /*
                More readable font, Like Arial in MS Word
                The background color is grey

                font-family: "verdana", sans-serif;
                background-color: #dddddd;
                foreground-color: #000000;

                Traditional "Book" and newspaper font
                font-family: "Times New Roman", serif;
            */
        }

        a:link
        {
            font-style: italic;
        }

        /*   A name=... link references */

        a.name
        {
            font-style: normal;
        }

        a:hover
        {
            color:           purple;
	    background:      #AFB;
            text-decoration: none;
        }

            /* cancel above italic in TOC and Navigation buttons */

        a.btn:link
        {
            font-style: normal;
        }

            /* each link in TOC */


        a.toc
        {
	    font-family: verdana, sans-serif;
            font-style: normal;
        }

        a.toc:link
        {
            font-style: normal;
        }

            /* [toc] heading button which appears in non-frame html */

        a.btn-toc:link
        {
            font-style: normal;
	    font-family: verdana, sans-serif;
            /* font-size:  0.7em; */
        }

        /*  //////////////////////////////////// Format the code sections  */

        /*  MSIE ok, Netscape nok: Indent text to same level to the right  */

        blockquote
        {
            margin-right: 0;
        }

        @media print   { BLOCKQUOTE
        {
            margin-right: 0;
        }}

        samp.code
        {
            color: Navy;
        }

        pre
        {
            font-family:   "Courier New", monospace;
            font-size:     0.8em;
        }

        pre.code
        {
	    color: Navy;
        }

	p.code, p.code1, p.code2
        {
            /*
               margin-top:     0.4em;
               margin-bottom:  0.4em;
               line-height:    0.9em;
            */

            font-family:    "Courier New", monospace;
            font-size:      0.8em;

            color:          Navy;
        }

	/* Make 3D styled layout by thickening the boton + right. */

	.3d-attrib
	{
	    /*
		F9EDCC		Light Orange
		FAEFD2		Even lighter Orange

		#FFFFCC		Light yellow, lime

	    */

	    background: #FFFFCC;
	}

	table.3d
	{
		font-family:    "Courier New", monospace;
		font-size:      0.8em;

		color:          #999999; /* Navy; */

		/* font-family:	sans-serif; /*
		/* background:	#F7DE9C; */

		/* border-top:	1px #999999 solid; */
		/* border-left:	1px #999999 solid; */
		border-right:	4px #666666 solid;
		border-bottom:	3px #666666 solid;
		/* line-height:	105%; */
	}


	table.shade
	{
		font-family:    "Courier New", monospace;
		font-size:      0.8em;

		color:          Navy;

		/* font-family:	sans-serif; /*
		/* background:	#F7DE9C; */

		/* border-top:	1px #999999 solid; */
		/* border-left:	1px #999999 solid; */
		/* border-right:	4px #666666 solid; */
		/* border-bottom:	3px #666666 solid; */
		/* line-height:	105%; */
	}

	.shade-attrib
	{
	    background: /* #EAEAEA; */
	}


	table.solid
	{
		font-family:    "Courier New", monospace;
		font-size:      0.8em;

		color:          Navy;

		/* font-family:	sans-serif; /*
		/* background:	#F7DE9C; */

		border-top:	1px #999999 solid;
		border-left:	1px #999999 solid;
		border-right:	1px #666666 solid;
		border-bottom:	1px #666666 solid;
		/* line-height:	105%; */
	}

        /* ////////////////////////////////////////////// Format columns */

        p.column3
        {
            color: Green;
        }

        p.column5
        {
            color: #87C0FF;   /* shaded casual blue */
        }

        p.column6
        {
	    /* #809F69 is Forest green
	       But web safe colors are:
	       Lighter  ForestGreen: 66CC00
	       ForestGreen: #999966 669900 339900 669966

            color: #669900;
	    font-family: "Goudy Old Style"
	    */
	    margin-left: 3em;
	    font-family: Georgia;
	    font-size:  0.9em;
        }

            /* This is so called 3rd heading */

        p.column7
        {
            font-style:  italic;
            font-weight: bold
        }

        @media print { P.column7
        {
            font-style:  italic;
            font-weight: bold
        }}

        p.column8
        {

        }

        p.column9
        {
            font-weight: bold;
        }

        p.column10
        {
            padding-top: 0;
        }

        em.quote10
        {
            /*
                #FF00FF Fuchsia;
                #0000FF Blue

                #87C0FF casual blue
                #87CAF0

		#A0FFFF Very light blue

                #809F69 = Forest Green , see /usr/lib/X11/rgb.txt

		background-color:

                color: #80871F ; Orange, short of

                # font-family: "Gill Sans", sans-serif;

		line-height: 0.9em;
                font-style:  italic;
	        font-size:   0.8em;

	        line-height: 0.9em;
	        color: #008080;

	        background-color: #F5F5F5;
		#809F69; forest green
		#F5F5F5; Pale grey
		#FFf098; pale green
		##bfefff; #ffefff; LightBlue1


             */

	     /*
	     #  See a nice page at
	     #  http://www.cs.helsinki.fi/linux/
	     #  http://www.cs.helsinki.fi/include/tktl.css
	     #
	     #  3-4 of these first fonts have almost identical look
	     #  Browser will pick the one that is supported
	     */

             font-family: lucida, lucida sans unicode, verdana, arial, "Trebuchet MS", helvetica, sans-serif;
	     background-color: #ffefff;
	     font-size:   0.8em;
        }

        @media print { em.quote10
        {
            font-style:  italic;
            line-height: 0.9em;
            font-size:   0.8em;
        }}

        p.column11
        {
	    font-family: arial, verdana, helvetica, sans-serif;
            font-size: 0.9em;
            font-style: italic;
            color: Fuchsia;
        }

        /* /////////////////////////////////////////////// Format words */

        em.word
        {
	    color: #809F69;  /*Forest green */
        }

        strong.word
        {

        }

        samp.word
	{
	    color: Blue;
            font-family:    "Courier New", monospace;
            /* font-size:      0.8em; */
	}

        span.super
        {
	    /* superscripts */
	    color: teal;
	    vertical-align: super;
	    font-family: Verdana, Arial, sans-serif;
	    font-size: 0.8em;
        }


        span.word-ref
        {
	    color: teal;
        }

        span.word-big
        {
	    color: teal;
	    font-size: 1.2em;
        }

        span.word-small
	{
	    color: #CC66FF;
	    font-family: Verdana, Arial, sans-serif;
	    font-size: 0.8em;
	}

        /* /////////////////////////////////////////////// Format other */

                /* 7th column starting with double quote */

        span.quote7
        {
            /* color: Green; */
            /* font-style: italic; */
		font-family: Verdana;
            font-weigh: bold;
	    font-size: 1.2em;
        }

                /* This appears in FRAME version: xxx-toc.html */

        div.toc
        {
            font-size: 0.8em;
        }

                /* This appears in picture: the acption text beneath */

        div.picture
        {
            font-style: italic;
        }


                /* This is the document info footer */

        em.footer
        {
            font-size: 0.9em;
        }

	END: Hide from older browsers



    </STYLE>


    <!-- ...................................................... Java code -->

    <SCRIPT TYPE="text/javascript">

        function MakeVisual(obj)
        {
            obj.style.fontWeight = "italic";
        }

        function MakeNormal(obj)
        {
            obj.style.fontWeight = "normal";
        }

        function IgnoreErrors()
        {
            return true;
        }

        window.onerror = IgnoreErrors;

    </SCRIPT>

</HEAD>

<BODY >
</P>
           </BLOCKQUOTE>
           <HR>
               <A name="document_id"  id="document_id"></A>
               <H1>
               1.0 Document id
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="description" id="description"></A>
  <H2>
      1.1 Description
      
  </H2>




        This document explains how do you deal with Emacs key bindings. In
        addition, you will find step by step how you use your X window's
        <SAMP class="word">xmodmap</SAMP> program to start using emacs better in X. Document also
        explains how to set up special xterm for telnet connections --
        running remote emacs with transparent key binding. Finally includes
        many ready examples and questions and answers compiled from Usenet
        emacs newsgroups.


<P class="column8">
        <EM><STRONG>$Id: emacs-keys-body.html,v 1.1 2005-12-04 20:58:46 hute37 Exp $</STRONG></EM><BR>


</P>
  <A name="required_preknowledge" id="required_preknowledge"></A>
  <H2>
      1.2 Required pre-knowledge
      
  </H2>




        You have to know enough about basic emacs commands; eg. what is
        <SAMP class="word">local-set-key</SAMP> <SAMP class="word">global-set-key</SAMP> and what's that <SAMP class="word">M-x</SAMP>. Refer to
        Emacs info pages (C-h i) for these matters. For the case study: I
        expect you to know enough elisp and enough about Unix programming
        to read presented code fluently.


</P>
  <A name="credits" id="credits"></A>
  <H2>
      1.3 Credits
      
  </H2>




        Many thanks to my fellow worker Uwe Geuder, who explained me how
        to deal with keys in X-environment. Without him I would be still
        using remote, but crippled emacs interface and you wouldn't be
        reading the case study results or the xmodmap explanation.

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="various_binding_methods"  id="various_binding_methods"></A>
               <H1>
               2.0 Various binding methods
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="foreword_to_different_emacs_platforms" id="foreword_to_different_emacs_platforms"></A>
  <H2>
      2.1 Foreword to different emacs platforms
      
  </H2>




        The old Emacs C-A-S-H-M modifiers map to new syntax like this:


<PRE class="code">
      old Emacs       Emacs 19.30+ and XEmacs19.14+
      [C-tab]         [(control tab)]
      [A-1]           [(alt ?1)]
      [S-up]          [(shift up)]
      [H-prior]       [(hyper prior)]   ;; in HP prior = PgUp
      [M-f1]          [(meta f1)]
</PRE>


<P class="column8">
        The [()] syntax in general works fine between the Emacs and XEmacs,
        but there are problems with the mouse symbol names, which are
        different. see this:


<PRE class="code">
      [(control shift mouse-1)]       ;; Emacs name:  mouse-1
      [(control shift button1)]       ;; XEmacs name: button1
</PRE>


</P>
  <A name="emacs_versions_and_key_binding" id="emacs_versions_and_key_binding"></A>
  <H2>
      2.2 Emacs versions and key binding syntax compatibility table:
      
  </H2>





<PRE class="code">
      m-1     : recognizes Emacs  styled mouse binding, mouse-1
      b1      : recognizes XEmacs styled mouse binding, button1
      r-k-m   : `read-kbd-macro'
      kdb     : New function `kbd' substitutes `read-kbd-macro'
      _yes    : works 95% , but there are known bugs.

      ------------------------------------------------------
      style:              []    [()]  m-1   b1    r-k-m  kbd
      ------------------------------------------------------
      Emacs   19.28-30    yes   no    yes   no    no     no
      Emacs   19.31-33    yes   yes   yes   no    bugs   no
      Emacs   19.34       yes   yes   yes   no    _yes   no
      Emacs   20.1-3      yes   yes   yes   ?     yes    yes
      ------------------------------------------------------
      XEmacs  19.13-14    no    yes   no    yes   no     no
      XEmacs  19.15-16    no    yes   _yes  yes   yes    no
      XEmacs  20.2-5      no    yes   yes   yes   yes    yes
      ------------------------------------------------------
</PRE>


<P class="column8">
        <SPAN class="word-ref">[SL Baur <EM><A HREF="mailto:steve@xemacs.org" >steve@xemacs.org</A></EM>]</SPAN> There is no XEmacs 20.1. There are two
        flavors of XEmacs 20.0 floating around. They are not compatible.
        One is more like XEmacs 19.14 (the one on the Sun CD), the other
        (the 'net released one) is more like XEmacs 19.15/16. Note that the
        form <SAMP class="word">[C-A-S-H-M]</SAMP> will never be supported by XEmacs.


</P>
  <A name="ethics_ndash_what_is_the" id="ethics_ndash_what_is_the"></A>
  <H2>
      2.3 Ethics &ndash; what is the correct way?
      
  </H2>





<P class="column10"><EM class="quote10">
          I'm totally confused. What binding method should I use?</EM>



<P class="column8">
        Please don't fell into despair. Things are not black or white and
        people have different habits and not everyone are interested in
        XEmacs and Emacs compatibility issues. Spend a while examining
        these bindings.


<PRE class="code">
      (global-set-key         &quot;\C-xm&quot;         'ignore)
      (define-key global-map  &quot;\C-xm&quot;         'ignore)
      (define-key global-map  (kbd &quot;C-x m&quot;)   'ignore) ;; Need 19.34+
      (define-key ctl-x-map   &quot;m&quot;             'ignore)
</PRE>


<P class="column8">
        I have purposively listed them in the order of my own preference. I
        usually choose the one that looks simplest, but that doesn't imply
        that it is the best or the right one. All the above examples work
        fine with variety of Emacs platforms. The only problem is <SAMP class="word">kbd</SAMP>,
        which is only supported by latest Emacs and was even less supported
        in old XEmacs releases.


<P class="column7"><EM><STRONG>
       2.3.1 Binding syntax recommendations</STRONG></EM>



<P class="column8">
        The most portable way is natural string syntax, just as you saw
        above. This will work in every possible Emacs: new or old,
        WindowsNT, Unix etc.


<PRE class="code">
      (define-key some-map &quot;keybindings&quot; 'ignore)
</PRE>


<P class="column8">
        Next best is XEmacs style binding, which is also supported by older
        Emacs versions:


<PRE class="code">
      (define-key some-map [(keybindings)] 'ignore)
</PRE>


<P class="column8">
        But remember that mouse bindings are not typically shared
        between XEmacs and emacs version. If you intend to have shared
        bindings, it would be best to write separate code for them:


<PRE class="code">
      (cond
       ((or (boundp 'xemacs-logo)  ;; This is XEmacs
            (featurep 'xemacs))    ;; New XEmacs releases define this
        (define-key some-map [(control shift button1)] 'ignore)
        ...other mouse bindings)
       (t
        (define-key some-map [(control shift mouse-1)] 'ignore)))
</PRE>


<P class="column8">
        Third best might be new <SAMP class="word">read-kdb-macro</SAMP> or <SAMP class="word">kbd</SAMP> way. I say third
        best, because it only works in latest Emacs and XEmacs
        versions. The <SAMP class="word">kbd</SAMP> was slightly buggy in WinNT 19.34. Expect this
        syntax to be reliable in NT Emacs 20.x and up. If you choose to use
        it, you 1) drop backward compatibility 2) but gain more readable
        format to set key bindings. Your call.

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="finding_the_key_syntax"  id="finding_the_key_syntax"></A>
               <H1>
               3.0 Finding the key syntax
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="know_your_environment_first" id="know_your_environment_first"></A>
  <H2>
      3.1 Know your environment first
      
  </H2>




        Running Emacs in window system is different from running Emacs in
        console mode: meaning that Emacs has been started either with <SAMP class="word">-nw</SAMP>
        or from telnet over vt100 like terminal (No X or other window
        system). Be prepared that the console Emacs can't use all the same
        bindings as your windowed Emacs.


<P class="column8">
        An example (Emacs):


<PRE class="code">
      Pressed key     C-h l [-nw] C-h l [windowed]
      ---------------------------------------------------
      Control-right   ESC O C     C-right
      Control-left    ESC O D     C-left
      Control-up      ESC O A     C-up
      Control-down    ESC O B     C-down
      Control-RET     RET         C-return        <
      Shift-RET       RET         S-return        <
</PRE>


<P class="column8">
        Notice how different the recognized keys are in these environments.
        Look closely last rows: in non-window environment the shift/control
        state is not passed at all when you press <SAMP class="word">return</SAMP>.


</P>
  <A name="the_mx_viewlossage_command_helps" id="the_mx_viewlossage_command_helps"></A>
  <H2>
      3.2 The M-x view-lossage command helps you
      
  </H2>




        Just press a &lt;key or sequence&gt; and immediately execute C-h l, or
        <SAMP class="word">M-x</SAMP> <SAMP class="word">view-lossage</SAMP> Then you can look at the key definition it
        produced. E.g. For <SAMP class="word">C-c</SAMP> <SAMP class="word">C-S-f1</SAMP> lossage buffer may show:


<PRE class="code">
      backspace S - F 1 SPC i t SPC s h o w s : return return
      C-c C-S-f1 C-h l
      ^^^^^^^^^^
</PRE>


<P class="column8">
        That is the exact form you can use:


<PRE class="code">
      (global-set-key [(control c) (control shift f1)] 'ignore)
</PRE>


</P>
  <A name="using_readkbdmacro" id="using_readkbdmacro"></A>
  <H2>
      3.3 Using read-kbd-macro
      
  </H2>




        Anonymous mentioned in gnu.emacs.help 1998-04-05
        in Message-ID: &lt;6g7obg$207@basement.replay.com&gt; that you can find
        the <SAMP class="word">read-kbd-macro</SAMP> syntax with following command:


<PRE class="code">
      (format-kbd-macro (read-key-sequence &quot;Key? &quot; nil t))C-uC-xC-e
</PRE>


<P class="column8">
        <SPAN class="word-ref">[Hrvoje Niksic <EM><A HREF="mailto:hniksic@srce.hr" >hniksic@srce.hr</A></EM>]</SPAN> ...the best and most reliable way
        to bind keys is using the function <SAMP class="word">read-kbd-macro</SAMP>. Preferred form
        as you needn't know the internal representation. A shortened form
        of <SAMP class="word">read-kbd-macro</SAMP> is called <SAMP class="word">kbd</SAMP> in XEmacs 20.2 and Emacs 19.34.
        It will also evaluate at compile-time.


<PRE class="code">
      (read-kbd-macro &quot;&lt;S-up&gt;&quot;)
      (read-kbd-macro &quot;&lt;M-f1&gt;&quot;)
      (read-kbd-macro &quot;A-1&quot;)
</PRE>


<P class="column8">
        The <SAMP class="word">read-kbd-macro</SAMP> function returns the internal Emacs
        representation of a human-readable string which is its argument.
        So:


<PRE class="code">
      (read-kbd-macro &quot;C-c C-a&quot;)
        =&gt; &quot;&quot;
        =&gt; [(control ?c) (control ?a)]          ; XEmacs

      (read-kbd-macro &quot;C-c C-. &lt;up&gt;&quot;)
        =&gt; [3 67108910 up]
        =&gt; [(control ?c) (control ?.) up]       ; XEmacs
</PRE>


<P class="column8">
        The function is convenient to use in your keyboard definitions, for
        example:


<PRE class="code">
      (global-set-key (read-kbd-macro &quot;C-.&quot;) 'undo)  ; or whatever
</PRE>


<P class="column8">
        The exact &quot;human-readable&quot; syntax is defined in the docstring of
        <SAMP class="word">edmacro-mode</SAMP>. I'll repeat it here, for completeness. Format of
        keyboard macros during editing:


<P class="column10"><EM class="quote10">
          Format of keyboard macros during editing:</EM>



<P class="column10"><EM class="quote10">
          Text is divided into &quot;words&quot; separated by whitespace. Except for
          the words described below, the characters of each word go directly
          as characters of the macro. The whitespace that separates words
          is ignored. Whitespace in the macro must be written explicitly,
          as in &quot;foo SPC bar RET&quot;.</EM>



<PRE class="code">
       * The special words RET, SPC, TAB, DEL, LFD, ESC, and NUL
         represent special control characters. The words must be
         written in uppercase.

       * A word in angle brackets, e.g., &lt;return&gt;, &lt;down&gt;, or &lt;f1&gt;,
         represents a function key.  (Note that in the standard
         configuration, the function key &lt;return&gt; and the control key
         RET are synonymous.)  You can use angle brackets on the
         words RET, SPC, etc., but they are not required there.

       * Keys can be written by their ASCII code, using a backslash
         followed by up to six octal digits. This is the only way to
         represent keys with codes above \377.

       * One or more prefixes M- (meta), C- (control), S- (shift), A-
         (alt), H- (hyper), and s- (super) may precede a character or
         key notation. For function keys, the prefixes may go inside
         or outside of the brackets: C-&lt;down&gt; = &lt;C-down&gt;.  The
         prefixes may be written in any order: M-C-x = C-M-x.

         Prefixes are not allowed on multi-key words, e.g., C-abc,
         except that the Meta prefix is allowed on a sequence of
         digits and optional minus sign: M--123 = M-- M-1 M-2 M-3.

       * The `^' notation for control characters also works:  ^M = C-m.

       * Double angle brackets enclose command names: <next-line>
         is shorthand for M-x next-line RET.

       * Finally, REM or ;; causes the rest of the line to be ignored
         as a comment.

      Any word may be prefixed by a multiplier in the form of a decimal
      number and `*':  3*&lt;right&gt; = &lt;right&gt; &lt;right&gt; &lt;right&gt;, and

      Any word may be prefixed by a multiplier in the form of a decimal
      number and `*':  3*&lt;right&gt; = &lt;right&gt; &lt;right&gt; &lt;right&gt;, and
      10*foo = foofoofoofoofoofoofoofoofoofoo.

      Multiple text keys can normally be strung together to form a word,
      but you may need to add whitespace if the word would look like one
      of the above notations:  `; ; ;' is a keyboard macro with three
      semicolons, but `;;;' is a comment. Likewise, `\ 1 2 3' is four
      keys but `\123' is a single key written in octal, and `&lt; right &gt;'
      is seven keys but `&lt;right&gt;' is a single function key. When in
      doubt, use whitespace.
</PRE>


<P class="column8">
        Other Traditional Emacs binding examples, binding f1 with various
        modifiers. Note that all the modifiers are not automatically
        available. It depends if the terminal can send appropriate key codes
        to emacs. E.g. for shifted function keys, X sends them while vt100
        doesn't.


<PRE class="code">
      (global-set-key [C-f1]          'ignore) ;control-f1
      (global-set-key [M-f1]          'ignore) ;meta-f1
      (global-set-key [C-S-f1]        'ignore) ;control-shift-f1
      (global-set-key [C-S-M-f1]      'ignore) ;control-shift-meta-f1
</PRE>


<P class="column8">
        And the same with the syntax that works in Emacs and XEmacs


<PRE class="code">
      (global-set-key (kbd &quot;&lt;C-f1&gt;&quot;)      'ignore)
      (global-set-key (kbd &quot;&lt;M-f1&gt;&quot;)      'ignore)
      (global-set-key (kbd &quot;&lt;C-S-f1&gt;&quot;)    'ignore)
      (global-set-key (kbd &quot;&lt;C-S-M-f1&gt;&quot;)  'ignore)

      ;; [jari] See how easy it is to bind C-. with this syntax
      (global-set-key (kbd &quot;C-.&quot;)         'ignore)
</PRE>


<P class="column8">
        And even newer Emacs releases have shortened the command
        <SAMP class="word">read-kbd-macro</SAMP> to <SAMP class="word">kbd</SAMP>. Put this into your ~/.emacs and you
        can start using the shorter name


<PRE class="code">
        (or (fboundp 'kbd)                    ;Std in Emacs 20.x
            (defmacro kbd (keys)              ;(kbd &quot;C-&lt;delete&gt;&quot;)
              &quot;Convert KEYS to the internal Emacs key representation.
              KEYS should be a string constant in the format used for
              saving keyboard macros (see `insert-kbd-macro').&quot;
              (let ((f 'read-kbd-macro))
                (funcall f keys))))
</PRE>


</P>
  <A name="very_easy_way_just_go" id="very_easy_way_just_go"></A>
  <H2>
      3.4 Very easy way: just go and use M-x global-set-key
      
  </H2>




        ...and hit the keys you want. Then go back and recall that previous
        command with <SAMP class="word">C-x</SAMP> <SAMP class="word">ESC</SAMP> <SAMP class="word">ESC</SAMP> and copy the output you see, and
        there is the full lisp command which does the binding.


<P class="column8">
        This will show you <SPAN class="word-ref">[C-c C-S-f1]</SPAN> when you bind the key, but when you
        recall the command it shrink to <SPAN class="word-ref">[3 C-S-f1]</SPAN>, so this method is not
        completely perfect.


</P>
  <A name="using_keydescription_by_kevin_rodgers" id="using_keydescription_by_kevin_rodgers"></A>
  <H2>
      3.5 Using key-description by Kevin Rodgers
      
  </H2>




        One more way to find out some cryptic emacs key bindings is to use
        function <SAMP class="word">key-description</SAMP>. See how following binding can be
        converted into human readable format


<PRE class="code">
      ;;  This cryptic number may not be reliable from platform
      ;;  to platform
      ;;
      (global-set-key  [4194336] 'set-mark-command)

      ;;  Make it more readable...The result depends on your Emacs
      ;;
      ;;  This gives in HP-UX     &quot;C-SPC&quot;
      ;;  And in NT Emacs         &quot;A-SPC&quot;
      ;;
      (key-description [4194336])

      ;; And C-SPC is represented with code...
      ;;
      (global-set-key [(control ?\  )] 'set-mark-command)
</PRE>

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="how_do_i_give_argument"  id="how_do_i_give_argument"></A>
               <H1>
               4.0 How do I give argument to command when I bind it to key?
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="printing_a_string_by_pressing" id="printing_a_string_by_pressing"></A>
  <H2>
      4.1 Printing a string by pressing a key
      
  </H2>




        You can make a key print arbitrary strings, like this


<PRE class="code">
      (global-set-key [(control right)] &quot;Hello there&quot;)
                                        ^^         ^^
</PRE>


<P class="column8">
        Notice the surrounding quotes. There is nothing magic in this,
        emacs just sees the first quote and decides, that it constitutes
        self-insert-command and echoes all characters when you press the
        key.


</P>
  <A name="running_macro_by_pressing_a" id="running_macro_by_pressing_a"></A>
  <H2>
      4.2 Running macro by pressing a key
      
  </H2>




        You can also put macro into a key, but I'm not going to teach
        macros here. Macros are fine for ad-hoc tasks, but if you need
        something complex and which can be handed to someone else, please
        try to learn equivalent lisp commands write functions. This
        is how you use macros in vanilla Emacs:


<P class="column8">
        o  C-x (, to start recording macro
        o  C-x ), to end recording
        o  M-x name-last-kbd-macro, to give it a name, say <SAMP class="word">my-macro-foo</SAMP>
        o  M-x call-last-kbd-macro, to run it or if you named the macro,
           call it with M-x my-foo-macro.


<P class="column8">
        <SPAN class="word-ref">[tip for windowed emacs]</SPAN>


<P class="column8">
        To use <STRONG class="word">one</STRONG> macro, and replace it every time, here are some handy
        bindings. The default C-x ( and C-x ) bindings are a bit
        uncomfortable.


<PRE class="code">
      ;;  Note, these are for HP keyboard, the idea is that you
      ;;  find 4 close keys, which you bind to these commands to
      ;;  access them fast.
      ;;
      ;;  In my kbd the keys are like this in upper row
      ;;  ... ( ) + =  backspace       shifted layout
      ;;
      ;; See also attached code to execute macro on region

      (global-set-key [(control ?\()] 'start-kbd-macro)
      (global-set-key [(control ?\))] 'end-kbd-macro)

      (global-set-key [(control ?\+)] 'my-call-last-kbd-macro-region)
      (global-set-key [(control ?\=)] 'call-last-kbd-macro)

      (defun my-call-last-kbd-macro-region (beg end)
        &quot;Calls last kbd macro for given region.&quot;
        (interactive &quot;r&quot;)
        (goto-char (min beg end))
        (call-last-kbd-macro (count-lines beg end)))
      ;; End
</PRE>


</P>
  <A name="running_existing_user_functions" id="running_existing_user_functions"></A>
  <H2>
      4.3 Running existing user functions
      
  </H2>




        Your key can run only <STRONG class="word">one</STRONG> command, and the attribute you give in
        key-binding must constitute of function symbol, self-insert command
        or vector macro. You denote symbols with prefixing name with a
        tick(').


<PRE class="code">
      (global-set-key [(control right)] 'forward-word)
                                        ^
                                        denotes symbol
</PRE>


<P class="column8">
        This is exactly the same as above, but help byte compiler more. For
        your own key bindings you don't need this, but if you make packages,
        then you may consider using this. New emacs releases have lisp
        reader syntax #'forward-word to do the same as (function
        forward-word).


<PRE class="code">
      (global-set-key [(control right)] (function forward-word))
</PRE>


<P class="column8">
        How do you know the function name to run? Use the <SAMP class="word">M-x</SAMP>
        <SAMP class="word">apropos-command</SAMP> to find all function like &quot;forward&quot; and select
        one from the displayed list.


</P>
  <A name="running_your_own_lisp_function" id="running_your_own_lisp_function"></A>
  <H2>
      4.4 Running your own lisp function
      
  </H2>




        When you may want to do more than call one function you have to
        start writing lisp. Because this paper is not about lisp, I'll just
        show simple example and how the command is attached to key.


<PRE class="code">
      (global-set-key [(f1)] 'my-command)

      (defun my-command ()
        &quot;Does something.&quot;     ;; < the doc string: C-h f my-command
        (interactive)         ;; < marks this function user callable
        (message &quot;I'm here&quot;)
        ...rest of the lisp commands)
</PRE>


<P class="column8">
        The method is no different than explained in the <SAMP class="word">forward-word</SAMP> case.
        This time just your function is called. Some important points:

<P><UL>
	<LI>Start your functions always with word &quot;my-&quot;. Do not put
            your initials in front of function names, because if you
            later post the solution, people do not like seeing 'joe-func,
            bill-func ...
	<LI>Remember to put (interactive) command in your function: all
            keyboard commands are &quot;interactive&quot;. The following error
	            normally signifies if you forgot the interactive command:
</UL>




<PRE class="code">
      (wrong-type-argument commandp  my-command)
</PRE>


</P>
  <A name="running_function_by_mouse_click" id="running_function_by_mouse_click"></A>
  <H2>
      4.5 Running function by mouse click
      
  </H2>




        For mouse commands, you need &quot;e&quot; flag; memorize it from (e)vent.
        Substitute mouse-3 with button3 in XEmacs.


<PRE class="code">
      (global-set-key [(control shift mouse-3)] 'my-mouse-command)

      (defun my-mouse-command (event)         ;; < notice `event'
        &quot;Does something.&quot;
        (interactive &quot;e&quot;)                     ;; < notice `e'

        ;; In Emacs you could also try
        ;; (message &quot;I'm here, point: %s&quot; (cdr (mouse-position)))
        (message &quot;I'm here&quot;)

        ...rest of the lisp commands)
</PRE>


<P class="column8">
        See more about the interactive command in the Emacs elisp info pages.


<P class="column8">
        Remember to include documentation string in functions too (real, or
        lambda ones). It helps you to keep track of key bindings. If you
        don't supply doc strings, the C-h b listing will show &quot;??&quot; for
        those keys which call functions that do not have documentation
        strings.


</P>
  <A name="calling_function_with_different_default" id="calling_function_with_different_default"></A>
  <H2>
      4.6 Calling function with different default argument
      
  </H2>




        Say you want different scroll command: you want to pass argument 1.
        In this simple case, when you aren't needing any additional
        commands, we use short lambda notation. Now I hear &quot;What on earth
        is lambda?&quot;. Well, The elisp pages will explain it better, let's
        just say, that it is anonymous function, i.e. it has no name to call
        at: you can think that the &quot;defun anonymous&quot; is replaced with a word
        &quot;lambda&quot;, otherwise writing the function is no different.


<PRE class="code">
      ;;  In my kbd the pgUp key is named PRIOR
      (global-set-key [(prior)]
        '(lambda () &quot;Previous&quot; (interactive) (scroll-down 1)))

      ;; Compare to this &quot;real function&quot; alternative

      (global-set-key [(prior)] 'my-scroll-down)

      (defun my-scroll-down ()
         &quot;Previous&quot;
          (interactive)
          (scroll-down 1)))
</PRE>


<P class="column8">
        Notice the leading single quote, emacs needs an symbol. If we want
        to be strict, the format


<PRE class="code">
      '(lambda
</PRE>


<P class="column8">
        isn't exactly the right one, but we'll decide that it suffices for
        our keybindings. Lisp programmers know that in packages the correct
        way is:


<PRE class="code">
      (function (lambda       or  just   (lambda   in newer emacs
</PRE>


<P class="column8">
        Passing one argument to external function required quite a lot lisp
        compared to this direct call with no arguments:


<PRE class="code">
      (global-set-key [(prior)] 'scroll-down)
</PRE>


<P class="column8">
        _Side Note_: If you have my Emacs libraries (lib 'm', tinylibm.el),
        you can write these short lambda functions with macro <SAMP class="word">definteractive</SAMP>
        Here is equivalent for to the problem of passing arg 1. You can't
        use the documentation string here though.


<PRE class="code">
      (global-set-key [(prior)] (definteractive (scroll-down 1)))
</PRE>


</P>
  <A name="using_complex_lambda_function_in" id="using_complex_lambda_function_in"></A>
  <H2>
      4.7 Using complex lambda function in key binding
      
  </H2>




        See the following example, which is more complicated.


<PRE class="code">
      (global-set-key [(f1)]
         '(lambda ()                          ;; anonymous function
            &quot;Displays simple message...&quot;      ;; don't forget doc string
            (interactive)
            (message &quot;I'm here&quot;)
            ;;  rest of the lisp commands
            ..))
</PRE>


<P class="column8">
        For simple solutions, lambdas are fine, but for most cases I prefer
        &quot;real&quot; functions. YMMV. Previous example was complex enough, so I
        reserve lambda for simple tasks only. Erm, what do I mean by &quot;real&quot;
        function then? It goes like this:


<PRE class="code">
      (global-set-key [(f1)] 'my-function)

      (defun 'my-function ()
        &quot;Displays simple message...&quot;
        (interactive)
        (message &quot;I'm here&quot;)
        ;;  rest of the lisp commands
        ;;  ..
        ))
</PRE>

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="about_key_maps"  id="about_key_maps"></A>
               <H1>
               5.0 About key maps
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="before_defining_the_key_you" id="before_defining_the_key_you"></A>
  <H2>
      5.1 Before defining the key, you should know about key maps
      
  </H2>




        File: emacs, Node: Keymaps, Node: Prefix Keymaps,<BR>
        File: emacs, Node: Minibuffer Maps<BR>


<P class="column8">
        You can't put the key into map if it doesn't exist, quite obvious?
        So you can't do this in your .emacs:


<PRE class="code">
      (define-key c++-mode-map &quot;\C-c1&quot; 'my-command)
                  ^^^^^^^^^^^^
</PRE>


<P class="column8">
        Because there is no such mode loaded into emacs (by default) which
        would initialize and define <SAMP class="word">c++-mode-map</SAMP>. An attempt will cause an
        error when emacs starts up. You can use following to check if map
        is around:


<PRE class="code">
      (and (boundp 'c++-mode-map)
           (keymapp c++-mode-map))
</PRE>


<P class="column8">
        It returns t or nil if the variable exists AND is a key map.
        Generally the <SAMP class="word">keymapp</SAMP> test isn't needed, since we know when the
        variable is a key map or not. See next chapter how we define the
        key into specific key map <STRONG class="word">after</STRONG> the the key map has been defined.


</P>
  <A name="default_emacs_key_maps_and" id="default_emacs_key_maps_and"></A>
  <H2>
      5.2 Default emacs key maps and packages' key maps
      
  </H2>




        These are predefined keypmaps which are always present


<PRE class="code">
      global-map
      (current-local-map)
      esc-map
      ..
</PRE>


<P class="column8">
        Which gives you the ability to use commands like:


<PRE class="code">
      (global-set-key ...)
      (local-set-key ...)
      (define-key esc-map ...)
</PRE>


<P class="column8">
        More about default key maps in emacs info pages. If the key map
        belongs to particular package (mode), then you should define keys
        <EM class="word">after</EM> the package gets loaded. This usually happens when the mode
        is turned on for the first time, and the autoload statements
        trigger the loading phase..(see 'autoload' info page)


<P class="column8">
        Next you have find out if the mode has a hook, which runs when the
        mode is turned on (just look at the sources, the .el files), the
        hooks are usually named according to mode, like:


<PRE class="code">
      MODE-NAME-hook
</PRE>


<P class="column8">
        Eg. for <SAMP class="word">text-mode</SAMP>, the hook name is <SAMP class="word">text-mode-hook</SAMP>. The maps for
        modes are also named similarly:


<PRE class="code">
      MODE-NAME-map
</PRE>


<P class="column8">
        So you actually want to do this, when you define something for
        <SAMP class="word">c++-mode</SAMP>:


<PRE class="code">
      ;; Install my own function into the hook. When mode is turned on
      ;; all the functions installed in this hook are run.

      (add-hook 'c++-mode-hook 'my-c++-mode-hook)

      (defun my-c++-mode-hook ()
        &quot;My C++ setting.&quot;

        ;; This is for advanced lip user:
        ;; - You know that `my-c++ -mode-hook' function runs after
        ;;   C++ mode which has already defined the key map.
        ;; - But the byte compiler does not know that. If you compile
        ;;   this file and don't say (require 'cc-mode), then it doesn't
        ;;   know that the key map exists and you get warning.
        ;; - We don't need (require 'cc-mode), so we just fool
        ;;   Byte Compiler to believe that the map is properly defined
        ;;   and get rid of the unnecessary warning.
        ;; - If you don't plan to byte compile your key binding
        ;;   settings or if the byte compiler warnings don't bother
        ;;   you (they are harmless), you can leave out this statement.

        (defvar c++-mode-map nil)  ;; No-op actually

        ;;  Now the mode is already &quot;defined&quot; (because we're mode hook),
        ;;  so the c++-mode-map is certainly available.

        (define-key c++-mode-map &quot;\C-c1&quot; 'my-command)

        ...other settings...)
</PRE>


</P>
  <A name="prefix_keymaps_in_new_emacs" id="prefix_keymaps_in_new_emacs"></A>
  <H2>
      5.3 Prefix keymaps in new emacs versions.
      
  </H2>




        In Emacs, I consider key <SAMP class="word">C-z</SAMP> pretty useless. In X it runs command
        <SAMP class="word">iconify-or-deiconify-frame</SAMP> which I never use. The C-z key is near
        the Shift modifier, so it's a perfect candidate for user's own
        prefix key. It's much more comfortable for pinky than the usual
        C-c; you avoid developing carpar tunnel syndrome to your wrist if
        you use the closest key possible.


<P class="column8">
        In new emacs, defining a prefix key is pretty simple:


<PRE class="code">
      ;;  If we try to set &quot;C-za&quot;  directly, ie. to use the
      ;;  C-z as prefix when it's not that yet, error is
      ;;  triggered --&gt; Unset key first
      ;;
      ;;  &quot;Key sequence C-z a uses invalid prefix characters&quot;
      ;;
      (global-set-key &quot;\C-z&quot; nil)

      ;;  Now we can assign any keys to it, eg. this command
      ;;  from tinyreplace.el, which performs replacing text more
      ;;  comfortable than query-replace :-)
      ;;
      (global-set-key &quot;\C-z%&quot;  'my-replace-forward)

      ;;  It also makes sense to group common functions under
      ;;  same key, eg. I have all _minor_ modes bound to map
      ;;  &quot;m&quot; under C-z map (or C-c, it depends).
      ;;
      (global-set-key &quot;\C-zmE&quot; 'eldoc-mode)    ;; eldoc.el
      (global-set-key &quot;\C-zmf&quot; 'folding-mode)  ;; folding.el
      (global-set-key &quot;\C-zmo&quot; 'font-lock-mode);; font-lock.el
      ...
</PRE>


</P>
  <A name="prefix_key_maps_in_old" id="prefix_key_maps_in_old"></A>
  <H2>
      5.4 Prefix key maps in old emacs versions.
      
  </H2>




        In older emacs versions you cannot define key maps so easily, like
        just giving keys after another in string notation: &quot;KeyKeyKey&quot;. You
        have to create a key map and put your keys there.


<PRE class="code">
      (require 'cl)
      ;;   We want to use use this key as prefix
      ;;
      (defconst my-key-prefix    &quot;\C-x\C-z&quot;
         &quot;My prefix map keys&quot;)

      ;;   What is the status of this key?
      ;;
      (defvar my-map (lookup-key global-map my-key-prefix))
      (unless (keymapp my-map)    ;not yet defined
        (setq my-map (make-sparse-keymap)))

      ;;  Okay, hook my map to this key
      ;;
      (define-key global-map my-key-prefix my-map)

      ;;  Now put keys into my private map.
      ;;
      (define-key my-map      &quot;\C-a&quot;  'my-function1)
      (define-key my-map      &quot;a&quot;     'my-function2)
      (define-key my-map      &quot;b&quot;     'my-toggle-buffer-name)
</PRE>


<P class="column8">
        This old way is more complicated, but offers, in some extent,
        flexibility: If you decide to move the map somewhere else, you only
        have to change the prefix to relocate the map:


<PRE class="code">
      (defconst my-key-prefix ...)
</PRE>


<P class="column8">
        In the other hand, you rarely change the key. If you can, use the
        newer method if it is available to you. Your .emacs stays much
        cleaner when there isn't extra key map definitions.


</P>
  <A name="functionkeymap_ndash_where_do_i" id="functionkeymap_ndash_where_do_i"></A>
  <H2>
      5.5 Function-key-map &ndash; where do I need it?
      
  </H2>




        When making bindings in <SAMP class="word">function-key-map</SAMP>, other bindings that
        affect a key will be bound automatically. <SAMP class="word">keyboard-translate-table</SAMP>
        also <STRONG class="word">remaps</STRONG> similarly. See following, where we make f10 key to
        work like C-x


<PRE class="code">
      (lookup-key global-map &quot;\C-x&quot;) --&gt; Control-X-prefix
      (define-key global-map [(f10)] 'Control-X-prefix)
</PRE>


<P class="column8">
        or use the following, which work only in X winsowed Emacs


<PRE class="code">
      (define-key global-map [(f10)] nil)
      (define-key function-key-map [(f10)] [?\C-x])
</PRE>


</P>
  <A name="how_to_generate_cashm_modifiers" id="how_to_generate_cashm_modifiers"></A>
  <H2>
      5.6 How to generate C-A-S-H-M modifiers from keyboard keys
      
  </H2>




        <SPAN class="word-ref">[Mohsin Ahmed <EM><A HREF="mailto:mosh@sasi.com" >mosh@sasi.com</A></EM>]</SPAN> You can generate the modifiers
        if your emacs doesn't generate them by default:


<PRE class="code">
      ;;  Now hyper-super-alt are missing on NT GNuEMacs,
      ;;  but see simple.el:3042

      (define-key function-key-map [(f5)] 'event-apply-super-modifier)
      (define-key function-key-map [(f6)] 'event-apply-alt-modifier)
      (define-key function-key-map [(f7)] 'event-apply-hyper-modifier)
      (define-key function-key-map [(f8)] 'event-apply-control-modifier)
</PRE>


</P>
  <A name="localsetkey_and_globalsetkey_note" id="localsetkey_and_globalsetkey_note"></A>
  <H2>
      5.7 Local-set-key and global-set-key note
      
  </H2>




        &quot;File: elisp, Node: Key Binding Commands&quot; Because you can run into
        deep troubles when trying to set some key-bindings, it's always
        good to try them out first; choose a mode that you don't use
        normally, like <SAMP class="word">pascal-mode</SAMP> and and use command:


<PRE class="code">
      local-set-key
</PRE>


<P class="column8">
        If you happend to mix up emacs somehow, don't panic, you only
        altered keys in the <SAMP class="word">pascal-mode-map</SAMP>.

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="ascii_and_nonascii_keys"  id="ascii_and_nonascii_keys"></A>
               <H1>
               6.0 Ascii and non-ascii keys
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="emacs_info_character_type" id="emacs_info_character_type"></A>
  <H2>
      6.1 Emacs info, Character Type
      
  </H2>




        File: elisp, Node: Character Type


<P class="column8">
        For historical reasons, Emacs treats the DEL character as the
        control equivalent of <SAMP class="word">?</SAMP>:


<PRE class="code">
      ?\^? =&gt; 127     ?\C-? =&gt; 127
</PRE>


<P class="column8">
        As a result, it is currently not possible to represent the
        character <SAMP class="word">Control-?</SAMP>, which is a meaningful input character under
        X. It is not easy to change this as various Lisp files refer to DEL
        in this way.


</P>
  <A name="general_description" id="general_description"></A>
  <H2>
      6.2 General description
      
  </H2>




        Your keyboard normally has qwerty keys, that has known ascii
        codes. You can use shift-key to double the keys, but they are still
        known ascii codes. But if you use any other modifier, the program
        behind it, must do some more snooping to determine what keys you
        pressed. In X it's possible to call Xlib functions (they return
        xevents), which tell the program that &quot;Flag xx is up, meaning that
        user pressed Control key.&quot;


<P class="column8">
        In Emacs, the string notation &quot;&quot; is reliable for ascii codes
        only. But any suspicious keys would be good to put into vector
        notation. If we try to determine the code for &quot;C-.&quot;, say using the
        (read-event) or calling global-set-key, and then recalling what was
        the lisp command, we would see some strange code for it:


<PRE class="code">
      [4194350]             in my HP-UX Emacs
</PRE>


<P class="column8">
        That's how the hardware represents the key. But instead of putting
        magical codes to define-key or global-set-key commands, you can use
        more portable alternative:


<PRE class="code">
      (read-kbd-macro &quot;&lt;C-.&gt;&quot;)
</PRE>


<P class="column8">
        There is a catch. With control keys, this vector notation works
        quite well, <STRONG class="word">but</STRONG> <STRONG class="word">for</STRONG> <STRONG class="word">alt</STRONG> <STRONG class="word">keys</STRONG> , the matter is totally
        different. See section about this later on, which proposes not to
        use alt keys if you want to have portable keys. (Alt may give you
        <SAMP class="word">Meta</SAMP> or <SAMP class="word">Alt</SAMP> depending on your keyboard setting)


</P>
  <A name="emacs_info_named_ascii_characters" id="emacs_info_named_ascii_characters"></A>
  <H2>
      6.3 Emacs info, Named ascii characters
      
  </H2>




        File: emacs, Node: Named ASCII Chars


<P class="column8">
        For example, I had to use my emacs in non-windowed environment and
        I had written all my bindings using the vector notation:


<PRE class="code">
      (global-set-key [?\e tab]       'hippie-expand)
</PRE>


<P class="column8">
        This works perfectly as long as emacs thinks the environment is
        <EM class="word">windowed</EM>. Now, I started the emacs like this in Xterm:


<PRE class="code">
      % emacs -nw
</PRE>


<P class="column8">
        And I was totally lost. My fine key bindings were wreckage and
        useless. The solution is to prefer equivalent &quot;character&quot; based key
        bindings


<PRE class="code">
      ;;  Works everywhere
      ;;
      (global-set-key &quot;\e\t&quot;          'hippie-expand)

      ;;  Nope, this won't work in non-Windowed emacs, it's like
      ;;  the  [?\e tab].
      ;;
      (global-set-key (read-kbd-macro &quot;&lt;M-tab&gt;&quot;) 'hippie-expand)
</PRE>


<P class="column10"><EM class="quote10">
          So prefer strings over the vectors if you can obtain the same
          results. And remember that <SAMP class="word">read-kbd-macro</SAMP> won't help you in
          non-windowed Emacs.</EM>



</P>
  <A name="case_study_why_cant_i" id="case_study_why_cant_i"></A>
  <H2>
      6.4 Case study: Why can't I assign key &lt;ESC C-'&gt; ?
      
  </H2>





<P class="column10"><EM class="quote10">
          ...I tried all these choices. What I'm doing wrong?
          None of these work..</EM>



<PRE class="code">
      (global-set-key [?\M-C-\'] 'myfunc)
      (global-set-key [?\C-M-\'] 'myfunc)
      (global-set-key [?\C-M-']  'myfunc)
      (global-set-key [?\M-C-']  'myfunc)
      (global-set-key [C-M-\']   'myfunc)
      (global-set-key [C-M-']    'myfunc)
      (global-set-key [\M-C-\']  'myfunc)
</PRE>


<P class="column8">
        Answer: If the Meta is your escape key, then you can use \e instead
        of M anywhere. The solution is first to look at what C-h l gives:


<PRE class="code">
      escape C-'
</PRE>


<P class="column8">
        So, let's turn it into key.


<PRE class="code">
      ;;  Works in XEmacs 19.15+ and Emacs 19.34+
      ;;
      (global-set-key [(control meta ?\')]        'myfunc)

      ;;  Alternatively way
      ;;  (WinNT Emacs 14.34 has bug here, doesn't work)
      ;;
      (global-set-key (read-kbd-macro &quot;&lt;C-M-'&gt;&quot;)  'myfunc)

      ;;  Emacs specific 1:
      (global-set-key  [?\e ?\C-'] 'myfunc)

      ;;  Emacs specific 2:
      ;;  Notice, that there is no questinon mark before the M,
      ;;  this is because the whole line means ONE char only,
      ;;  not multiple ones.
      ;;
      (global-set-key [?\C-\M-']  'myfunc)    ;; works
      (global-set-key &quot;\e\C-'&quot;     'myfunc)    ;; won't
</PRE>


<P class="column8">
        The last case doesn't work, instead it returns error, because the
        Ctrl-' isn't valid ascii code.


<PRE class="code">
          &quot;Invalid modifier in string.&quot;
</PRE>


</P>
  <A name="case_study_how_to_bind" id="case_study_how_to_bind"></A>
  <H2>
      6.5 Case study: How to bind a function to Ctrl-?
      
  </H2>




        Hrvoje Niksic <EM><A HREF="mailto:hniksic@srce.hr" >hniksic@srce.hr</A></EM> In new emacs where you can use the
        XEmacs style binding, this is easy


<PRE class="code">
      (global-set-key [(control ??)] 'foo)
</PRE>


<P class="column8">
        It has been reported that this was a bug in emacs up till 19.34,
        where the following Emacs binding, while valid, does not work


<PRE class="code">
      (global-set-key [?\C-\?] 'foo)
</PRE>


</P>
  <A name="portable_keybindings_ndash_command_emacs" id="portable_keybindings_ndash_command_emacs"></A>
  <H2>
      6.6 Portable keybindings &ndash; command 'emacs -nw' is your friend
      
  </H2>




        To have portable bindings, the key settings should work in any
        environment, no matter how you start your emacs. But if you're used
        to X environment, you probably haven't paid much attention in
        having a habit to use &quot;good&quot; keys. Not all keys are available in
        non-Windowed emacs, eg. there is no equivalent for this:


<PRE class="code">
      (global-set-key [(control return)] 'complete)
</PRE>


<P class="column8">
        You can't turn it into following, while it may seem quite
        obvious:


<PRE class="code">
      (global-set-key &quot;\C-\C-m&quot; 'complete)
</PRE>


<P class="column8">
        because the only key, that non-window Emacs recognizes, is pure
        return, with no modifiers, no Alt, Shift, Control. While you may
        not be interested in relocating your dear keys, at least you know
        what you may face when you haven't checked if the key combination
        is portable. It may be a good idea to group your key settings so,
        that there are sections like:


<PRE class="code">
      ;; ... ... ... ... ... ... ... ... windowed-only-bindings ..
      (global-set-key [(control return)] 'my-func1)
      (global-set-key [(shift   return)] 'my-func2)

      ;; ... ... ... ... ... ... ... ... ... .portable-bindings ..
      (global-set-key &quot;\e\t&quot;   'complete)
      (global-set-key &quot;\e\C-m&quot; 'hippie-expand)
</PRE>


<P class="column8">
        Later on, you can easily check which keys will not work in
        non-windowed environment. If you want to detect the case, when some
        keys are not available, you can use this lisp statement in your
        ~/.emacs


<PRE class="code">
      (cond
       (window-system
        ;;
        ;;  X-event key bindings work here
        (global-set-key [(control return)] 'my-func1)
        (global-set-key [(shift   return)] 'my-func2))
       (t
        ;;  Okay, user has non-windowed system, or has started
        ;;  emacs with % emacs -nw
        ;;  The string notation works only in this emacs.
        ;;  We may wish to relocate some X-event keys....
        ;;
        (global-set-key &quot;C-cM&quot; 'my-func1)
        (global-set-key &quot;C-cS&quot; 'my-func2)))
</PRE>


<P class="column8">
        But in most cases you only want to set the non-windowed case,
        because the window bindings do nothing if they are not available in
        non-windowed emacs. This example is identical to above one.


<PRE class="code">
      (require 'cl) ;; for `unless'

      ;;  These are no-op in non-windowed env.
      (global-set-key [(control return)] 'my-func1)
      (global-set-key [(shift   return)] 'my-func2)

      (unless window-system
        ;; non-windowed detected, should we relocate some  vector
        ;; keys to somewhere behind the prefix keys?
        ...)
</PRE>

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="emacs_backspace_binding_problem"  id="emacs_backspace_binding_problem"></A>
               <H1>
               7.0 Emacs backspace binding problem
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="recent_news_and_related_packages" id="recent_news_and_related_packages"></A>
  <H2>
      7.1 Recent news and related packages
      
  </H2>




        In XEmacs 20.3 you can just set


<PRE class="code">
      (setq delete-key-deletes-forward t)
</PRE>


<P class="column8">
        See also orwell.el, Exchange C-h &amp; DEL without affecting prefix
        mappings. Will Mengarini <EM><A HREF="mailto:seldon@eskimo.com" >seldon@eskimo.com</A></EM>


</P>
  <A name="foreword_ndash_background" id="foreword_ndash_background"></A>
  <H2>
      7.2 Foreword &ndash; background
      
  </H2>





<PRE class="code">
      (load-library &quot;delbackspace.el&quot;)
</PRE>


<P class="column8">
        <SPAN class="word-ref">[<EM><A HREF="mailto:kgallagh@spd.dsccc.com" >kgallagh@spd.dsccc.com</A></EM> Kevin Gallagher) in gnu.emacs.help]</SPAN>
        Unfortunately delbackspace.el is not part of the standard GNU Emacs
        distribution. The origin of your delete vs backspace problems under
        X Windows is found in ../lisp/term/x-win.el. Here are the
        particular lines and the associated comments:


<PRE class="code">
      ;; Map certain keypad keys into ASCII characters
      ;; that people usually expect.
      ;; Keys are defined in lisp/term/x-win.el
      ;;
      (define-key function-key-map [backspace] [127])
      (define-key function-key-map [delete] [127])
              .
              .
      ;; These tell read-char how to convert
      ;; these special chars to ASCII.
      ;;
      (put 'backspace 'ascii-character 127)
      (put 'delete    'ascii-character 127)
</PRE>


<P class="column8">
        They are seen both as a same character code. We have change the
        definition:


<PRE class="code">
      (define-key function-key-map [delete] &quot;\C-d&quot;)
      (put 'delete    'ascii-character 8)
</PRE>


<P class="column8">
        There is a lot of history behind the decision to configure Emacs
        this way. Here's the history, the fix comes later.


<P class="column10"><EM class="quote10">
          Emacs was first developed on a DEC PDP-11 (or similar vintage
          DEC computer) using DEC ascii terminals. On such terminals, the
          Del (aka Delete) key is part of the main keyboard located in the
          upper right portion and is used as a rubout key, i.e., it erases
          the character in front of the cursor and also moves the cursor
          back one space on the screen, taking the position of the erased
          character. On a DEC ascii terminal (such as the VT-100), the
          Del key generates a DEL character, octal 127. The VT-100 also
          has a BS (aka BackSpace) key and it generates the BS character,
          octal 010 (i.e., C-h). It's use varies with applications. The
          design of Emacs was tightly linked to the DEL character
          indicating rubout. C-h was chosen to invoke help so the BS key
          could be used as a help key on DEC terminals.</EM>



<P class="column8">
        On a Sun keyboard, the standard convention is for the BackSpace
        key to be used as a rubout key and the Del key be used to erase
        the character UNDER the cursor, not before it.


<P class="column8">
        So you can see that a lack of standards in keyboard design
        across computer vendors has created a support problem.


<P class="column8">
        Under X Windows, the BackSpace and Delete keys do not generate
        ascii characters, instead they present X Windows key codes to
        the applications. To make life a little easier, Emacs maps
        these key codes to names like &quot;delete&quot; and &quot;backspace&quot;. But so
        much of Emacs lisp code, especially major modes, expects to see
        a DEL character when rubout is intended, a fairly painless way
        to add X Windows support in the affected lisp code was to have
        Emacs map the X Windows key-code for the rubout key to a DEL
        character.


<P class="column8">
        In short, some keyboards use BackSpace as the rubout key and
        some use Delete. To ensure that users of both kind of keyboards
        always have a rubout key, x-win.el maps both BackSpace and
        Delete to the DEL character.


<P class="column8">
        Now for the fix. On a Sun keyboard, the BackSpace key serves as
        the rubout key and the Del key is designed to provide the
        feature which deletes the character under the cursor. This is
        broken under X with the default configuration in x-win.el.


<P class="column8">
        The BEST way to fix this is to map the Delete key to the Emacs
        function delete-char. Add the following to your .emacs file:


<PRE class="code">
      (add-hook 'term-setup-hook 'my-term-setup)

      (defun my-term-setup ()
        (define-key global-map [delete] 'delete-char))
</PRE>


<P class="column8">
        Using term-setup-hook minimizes the chance that something else
        might override your key definition during initialization.


</P>
  <A name="windowed_emacs_mapping" id="windowed_emacs_mapping"></A>
  <H2>
      7.3 Windowed Emacs mapping
      
  </H2>




<SPAN class="quote7">Jari Aalto</SPAN><BR>
        First we detect if emacs can differentiate them. Do following:


<PRE class="code">
      press backspace , press delete
      then hit C-h l to view the lossage buffer.
</PRE>


<P class="column8">
        If you see something like


<PRE class="code">
      backspace deletechar
</PRE>


<P class="column8">
        near the end of buffer then you know the emacs can separate them.
        the 'deletechar' may be 'del', 'delete' or something else in your
        system. Now you just set these keys where you want them. This is my
        emacs setup:


<PRE class="code">
      (global-set-key [backspace]  'delete-backward-char)
      (global-set-key [deletechar] 'delete-char)
</PRE>


<P class="column8">
<SPAN class="quote7">Nico Francois</SPAN><BR>
        gnu.emacs.help, that the following works in Windows 95.


<PRE class="code">
      ;; Redefine backspace to really mean backspace (and not delete)
      ;; and make delete do what we expect it to do.
      ;;
      (define-key function-key-map [backspace] [8])
      (global-set-key [backspace] 'delete-backward-char)
      (global-set-key [delete] 'delete-char)
</PRE>


<P class="column8">
<SPAN class="quote7">Kai Grossjohann</SPAN><BR>
        wrote immediately to comment the previous settings:


<P class="column8">
        A piece of advice from me: Do not redefine <EM class="word">both</EM> the backspace
        <EM class="word">and</EM> the delete key. This is because one of them gets mapped to
        DEL which is a special key that often changes its meaning in other
        modes, too (dired, view, ...). The above lines remove the mapping
        to DEL from both the backspace and the delete keys.


<P class="column8">
        I have just the following in my .emacs file which works fine for
        me under SunOS/X11R6:


<PRE class="code">
      (global-set-key [delete] 'delete-char)
</PRE>


<P class="column8">
        This replaces all of the above lines by Nico.


<P class="column8">
<SPAN class="quote7">by Chuck Taylor</SPAN><BR>
        backspace to work


<PRE class="code">
          (global-set-key &quot;\^?&quot;  'delete-char)
</PRE>


</P>
  <A name="nonwindowed_emacs_mapping" id="nonwindowed_emacs_mapping"></A>
  <H2>
      7.4 Non-windowed Emacs mapping
      
  </H2>




        This is my favorite, If you use both X and non-X, it'll detect the
        non-X, where the troubles usually start. After this code; the
        <SAMP class="word">delete</SAMP> key is out and produces the <SAMP class="word">C-h</SAMP> code. That's not a loss
        for me because I never use the <SAMP class="word">delete</SAMP> key, only the big fat
        <SAMP class="word">backspace</SAMP> key.


<PRE class="code">
      (require 'cl)
      ;; Define backspace key for Non-X Emacs
      ;;
      (when (not window-system)
        (setq key-translation-map (make-sparse-keymap))
        (define-key key-translation-map &quot;\177&quot; &quot;\C-h&quot;)
        (define-key key-translation-map &quot;\C-h&quot; &quot;\177&quot;)
        (defvar BACKSPACE &quot;\177&quot;)
        (defvar DELETE    &quot;\C-h&quot;)
        (global-set-key BACKSPACE 'backward-delete-char)
        )
</PRE>


</P>
  <A name="mapping_backspace_with_delete_symbol" id="mapping_backspace_with_delete_symbol"></A>
  <H2>
      7.5 Mapping backspace with 'delete' symbol
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:marc@watson.ibm.com" >marc@watson.ibm.com</A></EM> (Marc Auslander),  04 Jan 1996</EM>



<P class="column8">
        The following works. I'll say more below.


<PRE class="code">
      ;;  by Marc
      ;;  undo mapping of delete to DEL in x-win.el
      ;;  Then remap the key.
      ;;
      (define-key function-key-map [delete] nil)
      (global-set-key              [delete] 'delete-char)


      ;; by <EM><A HREF="mailto:schwab@lamothe.informatik.uni-dortmund.de" >schwab@lamothe.informatik.uni-dortmund.de</A></EM> (Andreas Schwab)
      ;; and Marc Auslander <EM><A HREF="mailto:marc@marc.watson.ibm.com" >marc@marc.watson.ibm.com</A></EM>:
      ;;
      (add-hook 'term-setup-hook 'my-term-setup-hook)

      (defun 'my-term-setup-hook ()
       ;;  undo mapping of delete to DEL in x-win.el
       ;;
       (define-key function-key-map [delete] nil)
       (global-set-key              [delete] 'delete-char))
</PRE>


<P class="column8">
        Now for the details. For historical reasons, you really want the
        key which you think of as backspace-and-delete to map to DEL, which
        is the character value 127. This is because lots of modes mess with
        the key map entry for DEL. So you DO NOT want to redefine the event
        associated with the key you use for backspace-and-delete.


<P class="column8">
        On the modern keyboards I use, I think the right key is the
        Backspace key, but apparently some people prefer the Delete key.
        In term/x-win.el both [backspace] and [delete] are mapped DEL using
        the function key map.


<P class="column8">
        The code above undoes that, and then lets you map [delete] as you
        please. Of course, you could modify it to use [delete] as DEL and
        [backspace] as something else if you prefer.

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="some_article_snippets_qa"  id="some_article_snippets_qa"></A>
               <H1>
               8.0 Some article snippets, Q/A
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="i_cant_use_cs_and" id="i_cant_use_cs_and"></A>
  <H2>
      8.1 I can't use C-s and C-q in emacs due to control flow.
      
  </H2>




        You have to call <SAMP class="word">M-x</SAMP> <SAMP class="word">enable-flow-control</SAMP>. When handling is
        enabled, user can type C-s as C-\, and C-q as C-^. With arg, enable
        flow control mode if arg is positive, otherwise disable.


</P>
  <A name="disable_cscq_for_flow_control" id="disable_cscq_for_flow_control"></A>
  <H2>
      8.2 Disable C-s/C-q for flow control?
      
  </H2>





<P class="column10"><EM class="quote10">
          Yes, I've read the FAQ but it just doesn't work. It would still
          freeze the screen after I typed either &quot;stty -ixon&quot; or &quot;stty
          start u stop u&quot;. I use dial-up from a home PC (Telix) to a Sun
          workstation (using vt120 emulation).</EM>



<P class="column8">
        <SPAN class="word-ref">[Richard Pieri <EM><A HREF="mailto:ratinox@unilab.dfci.harvard.edu" >ratinox@unilab.dfci.harvard.edu</A></EM>]</SPAN> Turn off software
        flow control at your modem and communication software, and turn on
        hardware (CTS/RTS) flow control.


</P>
  <A name="defining_keys_to_isearch_map" id="defining_keys_to_isearch_map"></A>
  <H2>
      8.3 Defining keys to isearch map?
      
  </H2>




        I am trying to get a function key <SAMP class="word">kp-f3</SAMP> to act just like
        C-s does...


<PRE class="code">
      ;; Answer by <EM><A HREF="mailto:ilia@gate.ispras.ru" >ilia@gate.ispras.ru</A></EM> (Elijah Perminov)
      ;;
      (define-key isearch-mode-map [kp-f3]
          (cons isearch-mode-map ?\C-S))

      (define-key isearch-mode-map [S-kp-f3]
          (cons isearch-mode-map ?\C-R))
</PRE>


</P>
  <A name="im_in_emacs_that_doesnt" id="im_in_emacs_that_doesnt"></A>
  <H2>
      8.4 I'm in emacs that doesn't recognize my function keys?
      
  </H2>




        Suppose you have heavily programmed your function keys (or any
        vector notation keys) and now you're in environment where these
        keys are not recognized. You don't want to remap your function
        keys, instead you have an idea of aliasing them to another keys.
        Say if you press &quot;ascii&quot; keys, then it would run your other keys.


<P class="column8">
        This can be done. Let's say we want C-c 1..9 to refer to f-keys, so
        that when pressing &quot;C-c1&quot; it would run function key f1. Here is the
        command that does it:


<PRE class="code">
      (global-set-key &quot;\C-c1&quot; [f1])
                              ^^^^
</PRE>


<P class="column8">
        Emacs sees the [f1] as an macro, and the macro is key press f1.  If
        we want to have one key to run multiple keys we'd do it like this:


<PRE class="code">
      (global-set-key &quot;\C-c1&quot; [f1 f5 f7])
</PRE>


<P class="column8">
        This would run keys f1, f5 and f7 one after another.


<P class="column8">
        Small note: you probably wonder why there is no tick(') before the
        vector, as we had in the function binding cases? Well, you could
        put the tick there like this:


<PRE class="code">
      (global-set-key &quot;\C-c1&quot; '[f1 f5 f7])
                              ^^
</PRE>


<P class="column8">
        But it is unnecessary, because the vector is &quot;self quoting&quot;,
        meaning that it does not need to be prefixed with the tick char.
        other self quoting types are:


<PRE class="code">
      t       true symbol
      nil     null symbol (or more traditionally: false symbol)
</PRE>


</P>
  <A name="i_dont_seem_to_see" id="i_dont_seem_to_see"></A>
  <H2>
      8.5 I don't seem to see the Control-Space sequence
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:hunger@hitech.com" >hunger@hitech.com</A></EM> (Henry Unger)</EM>



<P class="column8">
        Assume you are running non-X-windowed, you are probably using some
        type of terminal emulation. Terminal emulators send ASCII
        characters. There is no ASCII character C-Space, however, there is
        C-@ which produces an ASCII NUL character which is what set-mark is
        bound to (sort of). Some terminals (mistakenly) generate a C-@ when
        you press C-Space, hence the confusion. Try also following
        if the problem is in your Xterm.


<PRE class="code">
      #  .Xdefaults
      #
      XTerm*VT100*translations: #override Ctrl &lt;Key&gt;space: string(0x00)
</PRE>


</P>
  <A name="to_get_xterm_work_with" id="to_get_xterm_work_with"></A>
  <H2>
      8.6 To get Xterm work with mouse
      
  </H2>




        <SPAN class="word-ref">[Olaf Rogalsky <EM><A HREF="mailto:rogalsky@theorie1.physik.uni-erlangen.de" >rogalsky@theorie1.physik.uni-erlangen.de</A></EM>]</SPAN> After
        sending the escape sequence &quot;ESC [ 1000 h&quot; to a xterm, the xterm
        responds with an appropriate escape sequence to every mouse
        press/release, telling on wich character cell this has happened.


</P>
  <A name="does_these_vector_notations_work" id="does_these_vector_notations_work"></A>
  <H2>
      8.7 Does these vector, notations work only under X ?
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:abraham@ssv4.dina.kvl.dk" >abraham@ssv4.dina.kvl.dk</A></EM> (Per Abrahamsen)</EM>



<P class="column8">
        No, the vector notation works fine outside X11.


<P class="column8">
        If you look in the lisp/term/*.el you will see how Emacs maps from
        terminal dependent escape sequences into terminal independent
        symbols. Normally, Emacs will load the right one for you, but if
        not you can load it yourself with e.g.


<PRE class="code">
          (load &quot;term/vt100&quot;)
</PRE>


<P class="column8">
        in your .emacs file.


<P class="column8">
        <SAMP class="word">M-[</SAMP> was an Emacs 18 binding which was moved to <SAMP class="word">M-{</SAMP> in Emacs 19,
        precisely because it conflicted with the escape sequences produced
        by some common keyboards. If one is using Emacs 19, he could try


<PRE class="code">
          (global-unset-key &quot;\M-[&quot;)
</PRE>


<P class="column8">
        to undo the damage done by the other persons customization.


</P>
  <A name="i_have_troubles_running_screen" id="i_have_troubles_running_screen"></A>
  <H2>
      8.8 I have troubles running 'screen' (SUN-OS virtual term) and emacs
      
  </H2>





<P class="column10"><EM class="quote10">
          Kai Grossjohann <EM><A HREF="mailto:grossjoh@ls6.informatik.uni-dortmund.de" >grossjoh@ls6.informatik.uni-dortmund.de</A></EM></EM>



<P class="column10"><EM class="quote10">
          Ilya&gt; While running a program called &quot;screen&quot; and emacs, I<BR>
          Ilya&gt; noticed that the two programs interfere with each<BR>
          Ilya&gt; other. One specific error in example that you can<BR>
          Ilya&gt; duplicate yourself is hitting C-a in emacs. It will not<BR>
          Ilya&gt; take you to the begining of line as it should if screen<BR>
          Ilya&gt; is running. [...]</EM>
<BR>


<P class="column8">
        Screen has what is called a hot key. It intercepts all keyboard
        input and if it's the hot key it interprets this as a command to
        itself. If not, the key press is passed on to the underlying
        program. C-a is the default hot key in screen. I think you can hit
        the hot key twice to pass it to the underlying program.


<P class="column8">
        I've found backtick (`) to be a convenient hot key for screen, for
        about 5 minutes I've used it.


</P>
  <A name="modifying_keyboard_keys_in_x" id="modifying_keyboard_keys_in_x"></A>
  <H2>
      8.9 Modifying keyboard keys in X
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:psmith@lemming.wellfleet.com" >psmith@lemming.wellfleet.com</A></EM> (Paul D. Smith)</EM>



<P class="column8">
        Modify your keysymbols to your heart's content with a simple
        graphical representation of your keyboard--I did the above by
        copying the definition of one key to the other (actually I didn't
        swap them: who the heck needs a caps lock key? I just made two
        control keys :)


<P class="column8">
        Then tell the program to write out xmodmap codes to implement your
        changes, save 'em to a file, and tell xmodmap to run them each time
        you start X (in your ~/.xinitrc or wherever).


<PRE class="code">
      <A HREF="ftp://ftp.x.org/contrib/applications/" target="_top">ftp://ftp.x.org/contrib/applications/</A>  xkeycaps-2.29.tar.Z
</PRE>


</P>
  <A name="win95_swapping_ctrlcaps_keys" id="win95_swapping_ctrlcaps_keys"></A>
  <H2>
      8.10 Win95: swapping ctrl-caps keys ?
      
  </H2>




        <A HREF="http://cs.washington.edu/homes/voelker/" target="_top">http://cs.washington.edu/homes/voelker/</A>
        <A HREF="http://www.microsoft.com/windows/software/krnltoy.htm" target="_top">http://www.microsoft.com/windows/software/krnltoy.htm</A>


</P>
  <A name="swap_the_control_and_cap" id="swap_the_control_and_cap"></A>
  <H2>
      8.11 Swap the control and cap keys on Sun sparc 20 machine?
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:richter@taylor.math.nwu.edu" >richter@taylor.math.nwu.edu</A></EM> (Bill Richter)</EM>



<P class="column8">
        I don't know anything about sparc 20 keyboards. Here's a
        related Sun kbd stunt to get 2 more Meta keys &amp; 1 more Control


<PRE class="code">
      #   make the Alt key (between Caps Lock and Left-Meta) act as
      #   a Meta key similarly make the Compose key (right of
      #   Right-Meta) be Meta key

      xmodmap -e 'clear mod1'
      xmodmap -e 'keysym Alt_L = Meta_L'
      xmodmap -e 'keysym Multi_key = Meta_R'
      xmodmap -e 'add mod1 = Meta_L'
      xmodmap -e 'add mod1 = Meta_R'

      # make the Insert key (above Del) act as a control key
      xmodmap -e   &quot;keycode 51 = Control_L&quot;
      xmodmap -e 'add control = Control_L'
</PRE>


</P>
  <A name="xterm_ndash_aix_meta_key" id="xterm_ndash_aix_meta_key"></A>
  <H2>
      8.12 Xterm &ndash; AIX: Meta key missing in emacs -nw
      
  </H2>





<P class="column10"><EM class="quote10">
          Okay, here's a weird one. If I run an xterm on my local AIX 4.1.4
          machine and do an xemacs -nw in it, it doesn't recognize the meta
          key (meta-b just inserts a b), even though the tcsh running in
          that window recognized it just fine. However, if I rlogin or
          telnet to another machine, or EVEN TO THE SAME MACHINE, the meta
          key starts working.</EM>



<P class="column8">
        <EM><A HREF="mailto:kyle_jones@wonderworks.com" >kyle_jones@wonderworks.com</A></EM> (Kyle Jones)


<P class="column8">
        Your input character size is set to 7 bits. On ttys, the meta key
        sets the eighth bit on characters, but with 7-bit input enabled the
        high bit is either reset or used for parity. rlogin and telnet set
        the character size to 8 bits and leave it that way, and this is
        what is making the meta key work thereafter.


<PRE class="code">
      stty cs8
</PRE>


<P class="column8">
        should do the trick on POSIX-ish systems.


</P>
  <A name="hp_meta_key_missing_on" id="hp_meta_key_missing_on"></A>
  <H2>
      8.13 HP: meta key missing on 715 and 712?
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:jquinn@nortel.ca" >jquinn@nortel.ca</A></EM> (Jerry Quinn)</EM>



<P class="column8">
        The meta key problem on HP's can be fixed by using xmodmap. Do:


<PRE class="code">
      xmodmap -e &quot;remove mod1 = Mode_switch&quot;
</PRE>


<P class="column8">
        This makes Alt work fine for emacs. God knows why HP's stock setup
        is broken for emacs. Surely people inside HP use emacs, too.


</P>
  <A name="hp_theres_no_meta_key" id="hp_theres_no_meta_key"></A>
  <H2>
      8.14 HP: there's no Meta key?
      
  </H2>




        I'm using Hp console with its original Keyboard And As you know
        there's no Meta key and I'm using ESC key instead But it's really
        inconvenient... So i want to remap some key like caps lock or other
        some to Meta character. How can I do that? A:


<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:Jan.Braun@tu-bs.de" >Jan.Braun@tu-bs.de</A></EM> (Jan Braun)</EM>



<P class="column8">
        For the left Alt-key on my german HP-Keyboard. I put it into my
        ~/.xsession (~/.startxrc), so that it is automatically performed.


<PRE class="code">
      xmodmap -e &quot;clear mod1&quot; -e &quot;add mod1 = Meta_L&quot; -e\
          &quot;keycode 0x0a = Mode_switch&quot; -e\
          &quot;add Mod2 = Mode_switch&quot;
      echo &quot;Left ALTERNATE now META! Be carefull!&quot;
</PRE>


<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:marc@mpi.nl" >marc@mpi.nl</A></EM> (Marc Fleischeuers)</EM>



<P class="column8">
        I've stolen this from the net and stored it in a safe place. The
        repreat calls of `/../xmodmap -e' is merely paranoia, you can get
        by with placing eveything between &quot;&quot; in a file and run xmodmap on
        that.


<PRE class="code">
      /usr/bin/X11/xmodmap -e &quot;clear control&quot;
      /usr/bin/X11/xmodmap -e &quot;add control = Control_L&quot;
      /usr/bin/X11/xmodmap -e &quot;clear mod1&quot;
      /usr/bin/X11/xmodmap -e &quot;add mod1 = Meta_L&quot;
      /usr/bin/X11/xmodmap -e &quot;add mod1 = Meta_R&quot;
</PRE>


</P>
  <A name="hp_xmodmap_settings_in_pc" id="hp_xmodmap_settings_in_pc"></A>
  <H2>
      8.15 HP: xmodmap settings in PC XCeed
      
  </H2>




        I used to have HP console in front of me, but then we changed to
        Windows Nt machines running commercial X emulator XCeed, which has
        very nice keyboard layout configuration tools. However, if you're
        interested how I defined my keyboard for Emacs and for the rest of
        the X programs, here is the layout:


<PRE class="code">
      Left            Right

      Ctrl Alt        AltGr Ctrl      Physical keyboard keys
      |    |          |     |
      Ctrl Alt        Meta  Modifier  How they are seen by X server
</PRE>


<P class="column8">
        The left side gives me regular keys as I expect them, eg. the
        Alt keys really used to give me Meta, which wan't good at all
        The right hand side gioves me the other combos that I may need
        with other programs. The AltGr mapping(meta) is not necessarily
        that comfortable with Emacs; because Emacs has lot of Meta
        bindings. But I have got used to having meta to the right already.
        Below you see my <SAMP class="word">xmodmap</SAMP> settings and edited <SAMP class="word">xev</SAMP> results.


<PRE class="code">
      % xmodmap -pm

      shift       Shift_L (0x31),  Shift_R (0x3d)
      lock        Caps_Lock (0x41)
      control     Control_L (0x24)
      mod1        Alt_L (0x3f)
      mod2        Meta_R (0x5b)
      mod3        Mode_switch (0x5c)
      mod4
      mod5

      [Left Ctrl key]
      KeyRelease event, serial 17, synthetic NO, window 0x1400001,
          state 0x4, keycode 36 (keysym 0xffe3, Control_L)
          XLookupString gives 0 characters:  &quot;&quot;

      [Lef Alt key]
      KeyRelease event, serial 17, synthetic NO, window 0x1400001,
          state 0x8, keycode 63 (keysym 0xffe9, Alt_L)
          XLookupString gives 0 characters:  &quot;&quot;

      [Right Alt (AltGr in pc) key]
      KeyRelease event, serial 17, synthetic NO, window 0x1400001,
          state 0x10, keycode 91 (keysym 0xffe8, Meta_R)
          XLookupString gives 0 characters:  &quot;&quot;

      [Right Ctrl key]
      KeyRelease event, serial 17, synthetic NO, window 0x1400001,
          state 0x20, keycode 92 (keysym 0xff7e, Mode_switch)
          XLookupString gives 0 characters:  &quot;&quot;
</PRE>


</P>
  <A name="could_anyone_tell_me_how" id="could_anyone_tell_me_how"></A>
  <H2>
      8.16 Could anyone tell me how I could change the meta-key ?
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:sasdjb@unx.sas.com" >sasdjb@unx.sas.com</A></EM> (David Biesack)</EM>



<P class="column8">
        In HP system, you can rebind it:


<PRE class="code">
      xmodmap - <META
      ! Fix Extend Char keys to work as true Meta keys in GNU Emacs
      clear Mod1
      add Mod1 = Meta_L
      add Mod2 = Meta_R
      META
</PRE>


</P>
  <A name="how_can_i_set_meta" id="how_can_i_set_meta"></A>
  <H2>
      8.17 How can I set Meta key to Alt?
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:kwak@gloria.postech.ac.kr" >kwak@gloria.postech.ac.kr</A></EM> (Kwak Jong-Geun)</EM>



<P class="column8">
        Try to put something like this in your ~/.Xmodmap file, and invoke
        your xsession to read it using xmodmap promgram.


<PRE class="code">
      % cat ~/.Xmodmap

      !Right Alt key is used to Meta key
      keysym Mode_switch = Escape
      keysym Meta_R = Escape
</PRE>


<P class="column8">
        check your Alt key symbol name using xev, and put correct symbol.


</P>
  <A name="how_can_i_make_the" id="how_can_i_make_the"></A>
  <H2>
      8.18 How can I make the alt key work as the meta key?
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:kwak@gloria.postech.ac.kr" >kwak@gloria.postech.ac.kr</A></EM> (Kwak Jong-Geun):</EM>



<P class="column8">
        put next line in your ~/.Xmodmap, and check your startx session
        invoke the file using xmodmap program.


<PRE class="code">
      keysym Mode_switch = Escape
</PRE>


<P class="column8">
        It work for X window system, FreeBSD, emacs19.28.


</P>
  <A name="on_x_window_cspc_says" id="on_x_window_cspc_says"></A>
  <H2>
      8.19 On X window C-SPC says Args out of range #^[nil nil nil
      
  </H2>




        We just install the emacs 19.30 on Dec Alpha running DUnix 3.2C.
        When we use the emacs on X window, the C-SPC does not work by
        saying: Args out of range: #^[nil nil nil nil nil nil nil nil nil
        nil , But if we use emacs -nw, then C-SPC works fine.


<P class="column10"><EM class="quote10">
          Weiwen Liu <EM><A HREF="mailto:liu@yalph2.physics.yale.edu" >liu@yalph2.physics.yale.edu</A></EM> later posted:</EM>



<P class="column8">
        If I remove (enable-flow-control-on &quot;vt100&quot; &quot;vt300&quot; &quot;xterms&quot;
        &quot;xterm&quot;) then C-SPC works fine!


</P>
  <A name="carpal_tunnel_syndrome_any_way" id="carpal_tunnel_syndrome_any_way"></A>
  <H2>
      8.20 Carpal tunnel syndrome: Any way to reduce left wrist pain?
      
  </H2>





<P class="column10"><EM class="quote10">
          Bill Richter <EM><A HREF="mailto:richter@conley.math.nwu.edu" >richter@conley.math.nwu.edu</A></EM></EM>



<P class="column8">
        I've bound (on X Windows Emacs) the 4 &quot;island&quot; arrow keys on a Sun
        ELC kbd to Control, and three common prefixes, <SAMP class="word">C-x</SAMP>, <SAMP class="word">C-c</SAMP> and
        <SAMP class="word">C-h</SAMP>. In my .xinitrc:


<PRE class="code">
      xmodmap -e &quot;keycode 27 = Control_L&quot;       # Up
      xmodmap -e &quot;keycode 31 = Select&quot;          # Left
      xmodmap -e &quot;keycode 34 = KP_2&quot;            # Down
      xmodmap -e &quot;keycode 35 = KP_F4&quot;           # Right

      xmodmap -e 'add control = Control_L'
</PRE>


<P class="column8">
        and in my .emacs


<PRE class="code">
      (global-set-key [(f16)] 'execute-extended-command)   ;Copy = M-x

      (define-key global-map [(select)] nil)
      (define-key function-key-map [(select]) [?\C-x])

      (define-key global-map [(kp-2] nil)
      (define-key function-key-map [(kp-2)] [?\C-c])

      (define-key global-map [(kp-f4)] nil)
      (define-key function-key-map [kp-f4] [?\C-h])

      (define-key global-map [(insert)] nil)
      (define-key function-key-map [(insert)] [?\C-s])

</PRE>


<P class="column8">
        I don't need these arrow keys because there's another set on the
        numeric keypad. I chose the keysyms <SAMP class="word">Select</SAMP>, <SAMP class="word">KP_2</SAMP>, <SAMP class="word">KP_F4</SAMP>
        because they were vacant and because xterm accepts them over a
        modem, although I have not really learned how to bind them (in
        emacs -nw).


<P class="column8">
        I also bound <SAMP class="word">C-s</SAMP> to the next key over, the <SAMP class="word">0=Ins</SAMP> numeric
        keypad, which is bound by default with no xmodmap monkey business
        to <SAMP class="word">overwrite-mode</SAMP> (horrible binding for novices!!!).  Continuing
        the ergo story, I re-xmodmapped most of the keypad because the
        default Sun keysyms are dead keys over the modem:


<PRE class="code">
      xmodmap -e &quot;keycode 119 = KP_1&quot;
      xmodmap -e &quot;keycode 121 = KP_3&quot;
      xmodmap -e &quot;keycode 99 = KP_5&quot;
      xmodmap -e &quot;keycode 75 = KP_7&quot;
      xmodmap -e &quot;keycode 77 = KP_9&quot;

      (global-set-key [(kp-7)] 'beginning-of-buffer)
      (global-set-key [(kp-9)] 'scroll-down)
      (global-set-key [(kp-5)] 'recenter)
      (global-set-key [(kp-1)] 'end-of-buffer)
      (global-set-key [(kp-3)] 'scroll-up)
</PRE>


<P class="column8">
        Before I'd bound these commands to the top row of function keys
        over a modem. I'm sure the top row are the least ergonomically
        sound keys, I have to lunge for them, the numeric keypad is much
        nicer.


<P class="column8">
        The list of keysyms comes from the Emacs manual node &quot;Function
        Keys.&quot;


</P>
  <A name="telnet_connection_ndash_backspace" id="telnet_connection_ndash_backspace"></A>
  <H2>
      8.21 Telnet connection &ndash; backspace ?
      
  </H2>




        I have an xterm which I telnet from to get access to the internet
        service provider from work. I would like to map the keys in the
        xterm like they are mapped in X or in Presentation manager. I want
        the &quot;Alt&quot; key mapped to the &quot;Meta&quot; key and I want the backspace key
        to give me backspace and the control-h key to give me help.


<P class="column10"><EM class="quote10">
          mlehmann@prismnet.com (Mark Lehmann):</EM>



<P class="column8">
        I created a solution that works. Where would be a good place to
        distribute this. I think that it would be handy for many
        people.


<P class="column8">
        This is a list of the .Xdefaults settings. I have tried to minimize
        the number of translations. The &quot;xterm&quot; termcap entry already
        defines the function keys and the Insert, Delete, Page Up, Page
        Down keys so I did not redefine these. Make sure to have the
        following to shell settings when you use the xterm (not aixterm):


<PRE class="code">
      export TERM=xterm
      # Force off Flow-Control so you can use Ctrl-S and Ctrl-Q
      stty -ixon

      xterm*Translations: #override\
         &lt;Key&gt;BackSpace: string) \n\
         Mod1&lt;Key&gt;a: string(0x1b) string(&quot;a&quot;) \n\
         Mod1&lt;Key&gt;b: string(0x1b) string(&quot;b&quot;) \n\
         Mod1&lt;Key&gt;c: string(0x1b) string(&quot;c&quot;) \n\
         Mod1&lt;Key&gt;d: string(0x1b) string(&quot;d&quot;) \n\
         Mod1&lt;Key&gt;e: string(0x1b) string(&quot;e&quot;) \n\
         Mod1&lt;Key&gt;f: string(0x1b) string(&quot;f&quot;) \n\
         Mod1&lt;Key&gt;g: string(0x1b) string(&quot;g&quot;) \n\
         Mod1&lt;Key&gt;h: string(0x1b) string(&quot;h&quot;) \n\
         Mod1&lt;Key&gt;i: string(0x1b) string(&quot;i&quot;) \n\
         Mod1&lt;Key&gt;j: string(0x1b) string(&quot;j&quot;) \n\
         Mod1&lt;Key&gt;k: string(0x1b) string(&quot;k&quot;) \n\
         Mod1&lt;Key&gt;l: string(0x1b) string(&quot;l&quot;) \n\
         Mod1&lt;Key&gt;m: string(0x1b) string(&quot;m&quot;) \n\
         Mod1&lt;Key&gt;n: string(0x1b) string(&quot;n&quot;) \n\
         Mod1&lt;Key&gt;o: string(0x1b) string(&quot;o&quot;) \n\
         Mod1&lt;Key&gt;p: string(0x1b) string(&quot;p&quot;) \n\
         Mod1&lt;Key&gt;q: string(0x1b) string(&quot;q&quot;) \n\
         Mod1&lt;Key&gt;r: string(0x1b) string(&quot;r&quot;) \n\
         Mod1&lt;Key&gt;s: string(0x1b) string(&quot;s&quot;) \n\
         Mod1&lt;Key&gt;t: string(0x1b) string(&quot;t&quot;) \n\
         Mod1&lt;Key&gt;u: string(0x1b) string(&quot;u&quot;) \n\
         Mod1&lt;Key&gt;v: string(0x1b) string(&quot;v&quot;) \n\
         Mod1&lt;Key&gt;w: string(0x1b) string(&quot;w&quot;) \n\
         Mod1&lt;Key&gt;x: string(0x1b) string(&quot;x&quot;) \n\
         Mod1&lt;Key&gt;y: string(0x1b) string(&quot;y&quot;) \n\
         Mod1&lt;Key&gt;z: string(0x1b) string(&quot;z&quot;)
</PRE>


</P>
  <A name="latin_charset_handling" id="latin_charset_handling"></A>
  <H2>
      8.22 Latin Charset handling ?
      
  </H2>





<P class="column10"><EM class="quote10">
          Qing Long:</EM>



<PRE class="code">
      ;; The next 3 lines just enable ISO latin 1 charset handling
      (set-input-mode 't 'nil '8 )
      (require 'disp-table)
      (standard-display-8bit 128 255)
</PRE>


</P>
  <A name="linux_i_cant_rebind_cup" id="linux_i_cant_rebind_cup"></A>
  <H2>
      8.23 Linux: I can't rebind C-up in terminal window?
      
  </H2>





<P class="column10"><EM class="quote10">
          Kai Grossjohann <EM><A HREF="mailto:grossjoh@ls6.informatik.uni-dortmund.de" >grossjoh@ls6.informatik.uni-dortmund.de</A></EM></EM>



<P class="column8">
        You want to change the Linux keymap. See usr/lib/kbd/keytables,
        there is a README there, I think, and there are files emacs.map and
        emacs2.map (to be loaded with loadkey or something). Also see the
        command showkey which helps you to modify a map by showing you the
        keycode of any key you type. It's not all that difficult. The
        easiest would be to just load emacs2.map and see what happens.


</P>
  <A name="linux_cursor_keys_problem" id="linux_cursor_keys_problem"></A>
  <H2>
      8.24 Linux: cursor keys problem
      
  </H2>





<P class="column10"><EM class="quote10">
          Emilio Lopes <EM><A HREF="mailto:ecl@fnpc21.if.usp.br" >ecl@fnpc21.if.usp.br</A></EM></EM>



<P class="column8">
        I have discovered ebuff-menu.el, which uses electric.el removes all
        keymaps, including the prefix keymaps and because my cursor keys
        produce prefix &quot;\M-[&quot;, this is a great problem.


<P class="column8">
        To make cursor keys available again you have to do this:


<PRE class="code">
      ;;  In linux the prefix seems to be M-[
      ;;  vt100 seems to produce          ^[O
      ;;
      (defconst my-arrow-prefix &quot;\M-[&quot;
        &quot;*This depends on your terminal. See C-q &lt;cursor-up&gt;&quot;)

      (defun my-keep-cursor-available ()
        &quot;Keeps the cursor key prefix available.
         See var my-arrow-prefix&quot;
         (if (not (null (lookup-key (current-local-map)
                          my-arrow-prefix)))
             ;; make prefix available again, so that cursor
             ;; keys work.
             (local-set-key my-arrow-prefix nil)))

      (add-hook 'electric-buffer-menu-mode-hook
                'my-keep-cursor-available)
</PRE>

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="xmodmap_introduction_ndash_changing_your"  id="xmodmap_introduction_ndash_changing_your"></A>
               <H1>
               9.0 Xmodmap introduction &ndash; Changing your X environment
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="how_x_key_bindings_work" id="how_x_key_bindings_work"></A>
  <H2>
      9.1 How X key bindings work
      
  </H2>




        This may not be very through explanation, but it intends to give
        you basic understanding. Let's start our journey as explained
        by fellow worker Uwe Geuder.


<P class="column10"><EM class="quote10">
          REMEMBER</EM>



<P class="column10"><EM class="quote10">
          If you ever use xmodmap, it affects all your programs immediately
          since the change is done in X server itself. Before doing
          anything, run</EM>



<PRE class="code">
          xmodmap -pm
</PRE>


<P class="column10"><EM class="quote10">
          and save the default to somewhere safe. You can't do xmodmap
          locally, for one program, like emacs...</EM>



<P class="column8">
        First thing to know is, that every program that you use in X must
        communicate with your X server. If you press some key, the programs
        gets its response from X-server.


<PRE class="code">
              keypress
      PROGRMAM    --&gt;     X SERVER
                          - Does lookup, how the key is set in xmodmap
                  &lt;--     - returns &quot;translated&quot; response
</PRE>


<P class="column8">
        Your keyboard has physical keys, that can be examined with the
        &quot;xev&quot; program. See &quot;xev &ndash; Spot your X-events(keys) easily&quot; later
        in this document. In my HP it tells for right alt key:


<PRE class="code">
      Physical (Keycode 10) --&gt; is mapped to X symbol (keysym Meta_R)
</PRE>


<P class="column8">
        Now the xmodmap program can change the translation, so that you can
        move right alt to mean something else:


<PRE class="code">
      [if we'd do xmodmap -e &quot;keycode 10 = Alt_R&quot; ]
      Physical (Keycode 10) --&gt; is mapped to X symbol (Alt_R)
</PRE>


<P class="column8">
        Now lets' take a look at the output of command xmodmap -pm in my
        console


<PRE class="code">
      --&gt;   shift       Shift_R (0xc),  Shift_L (0xd)
      --&gt;   lock        Caps_Lock (0x37)
            control     Control_R (0x8),  Control_L (0xe)
            mod1        Meta_R (0xa),  Meta_L (0xb), Mode_switch (0x36)
            mod2
            mod3
            mod4
            mod5
</PRE>


<P class="column8">
        The indicated row <EM class="word">names</EM>: shift, lock, control, mod1-5 mean, that
        whenever you press Shift_R (a X symbol, remember?) it produces X
        state &quot;shift&quot;. Accordingly Shift_L produces also state &quot;shift&quot;


<P class="column8">
        The mode_switch is a bit special, because if it's in the same row
        with Meta_R and Meta_L. This indicates, that when you press These
        meta keys (that are my alt keys), they produce special <EM class="word">mode</EM>
        key-codes which you can see form the xmodmap -pk listing


<PRE class="code">
                 char1      char2              char3            char4
      105 0x004f (O)  0x0000 (NoSymbol)  0x00f8 (oslash)  0x00d8 (Ooblique)
      |   |      |    |                  |                |
      |   |      |    |                  |                with &quot;shift&quot;
      |   |      |    |                  |                and  &quot;mode_switch&quot;
      |   |      |    |                  with &quot;mode_switch&quot;
      |   |      |    with &quot;shift&quot; state
      |   |      ordinary char &quot;as is&quot;
      |   In hex
      raw keycode
</PRE>


<P class="column8">
        If we want to use Meta_R (that was physical key &quot;alt right&quot;), for
        other purposes, we have to change the physical mapping of it and
        put it into another &quot;state row&quot;.


<P class="column8">
        The following example shell script demonstrates how I moved my HP's
        right Alt and Control keys to mean A- and H- modifiers in emacs.


<PRE class="code">
      #!/bin/sh
      #
      # program : xmodmap-my.sh
      # Author  : Jari Aalto
      # $Docid: 2002-03-03 Jari Aalto $
      # $Contactid: jari.aalto@poboxes.com $
      #
      # @(#)  KEYS    Redefines X-server keymap
      #
      # DESCRIPTION
      #
      #       This makes some new keys available in the HP console
      #       Mainly for emacs, so that it gives more modifiers to map
      #       keys to.
      #
      #       1. Defines Right Alt  --&gt; A-
      #       2. Define  Right Ctrl --&gt; H-
      #
      #
      # THE XMODMAP BEFORE
      #
      #       Use command &quot;xmodmap -pm&quot;
      #
      #       The default keysettings as logged in my HP console
      #       (localhost aapo)
      #
      #       shift       Shift_R (0xc),  Shift_L (0xd)
      #       lock        Caps_Lock (0x37)
      #       control     Control_R (0x8),  Control_L (0xe)
      #       mod1        Meta_R (0xa),  Meta_L (0xb),  Mode_switch (0x36)
      #       mod2
      #       mod3
      #       mod4
      #       mod5
      #
      #
      # HOW TO CHANGE THE XMODMAP
      #
      #       1a. As you can see in the table, we must first take
      #           out the mode_switch. Using mode_switch in
      #           the same line says to emacs that it should
      #           produce &quot;Mode keysym&quot; when pressing Alt.
      #           --&gt; You see that C-h c [Alt-a] produces some
      #               strange M-&lt;CHAR&gt;, where &lt;CHAR&gt; is some
      #               cryptic character.
      #           --&gt; my kbd does not have physical &quot;mode&quot; key,
      #               so I just remove that mapping.
      #       1b. Remove left alt key (Meta_R) and Control_R.
      #           These will have special meaning later.
      #
      #       2a. Map the physical key (10, Alt right) to new
      #           X keysymbol ALT
      #       2b. Map key (8 Control right) to new X
      #           keysymbol HYPER
      #
      #       3a. Now Tell X that there is new modifier, HYPER
      #       3b. Now Tell X that there is new modifier, ALT
      #
      # THE XMODMAP AFTER THE CHANGES
      #
      #           Notice that there is two &quot;,&quot; marks t the
      #           beginning of lines. This may some message from
      #           xmodmap...but I can't tell what.
      #
      #       shift       Shift_R (0xc),  Shift_L (0xd)
      #       lock        Caps_Lock (0x37)
      #       control   ,  Control_L (0xe)
      #       mod1      ,  Meta_L (0xb)
      #       mod2        Hyper_R (0xa)
      #       mod3        Alt_R (0x8)
      #       mod4
      #       mod5
      #


      xmodmap \
       -e 'remove mod1 = Mode_switch' \
       -e 'remove mod1 = Meta_R'      \
       -e 'remove mod1 = Control_R'   \
      \
       -e 'keycode  8  = Hyper_R'     \
       -e 'keycode  10 = Alt_R'       \
      \
       -e 'add mod2 = Hyper_R'        \
       -e 'add mod3 = Alt_R'          \
       ;

      # xmodmap-my.sh ends here
</PRE>


</P>
  <A name="xmodmap_and_keysyms_ndash_as" id="xmodmap_and_keysyms_ndash_as"></A>
  <H2>
      9.2 Xmodmap and keysyms &ndash; as explained in the 'xkeycaps'
      
  </H2>




        An exellent english explanation (but hard for non-English people)
        about the Mode_switch and and other modifiers can be found from
        xkeycaps(1) program's man page.


<PRE class="code">
      Jamie Zawinski <EM><A HREF="mailto:jwz@netscape.com" >jwz@netscape.com</A></EM>
      <A HREF="http://www.netscape.com/people/jwz/xkeycaps/" target="_top">http://www.netscape.com/people/jwz/xkeycaps/</A>
</PRE>


<P class="column8">
        Use archie to find the program: It allows mapping keys very
        conveniently provided that your keyboard happens to be
        supported. (HP keyboards aren't). The following is an excerpt from
        it.


<P class="column9"><STRONG>
         KEYSYMS AND KEYCODES</STRONG>



<P class="column9"><STRONG>
         The following description is from the X Protocol document, and is
         reprinted here for your convenience:</STRONG>



<P class="column10"><EM class="quote10">
          A list of KeySyms is associated with each KeyCode. If that list
          (ignoring trailing NoSymbol entries) is a single KeySym <SAMP class="word">`K</SAMP>',
          then the list is treated as if it were the list ``K NoSymbol K
          NoSymbol''. If the list (ignoring trailing NoSymbol entries) is a
          pair of KeySyms ``K1 K2'', then the list is treated as if it were
          the list ``K1 K2 K1 K2''. If the list (ignoring trailing NoSymbol
          entries) is a triple of KeySyms ``K1 K2 K3'', then the list is
          treated as if it were the list ``K1 K2 K3 NoSymbol''.</EM>



<P class="column10"><EM class="quote10">
          The first four elements of the list are split into two groups of
          KeySyms. Group 1 contains the first and second KeySyms, Group 2
          contains third and fourth KeySyms. Within each group, if the
          second element of the group is NoSymbol, then the group should be
          treated as if the second element were the same as the first
          element, except when the first element is an alphabetic KeySym
          <SAMP class="word">`K</SAMP>' for which both lowercase and uppercase forms are defined.
          In that case, the group should be treated as if the first element
          were the lowercase form of <SAMP class="word">`K</SAMP>' and the second element were the
          uppercase form of <SAMP class="word">`K</SAMP>'.</EM>



<P class="column10"><EM class="quote10">
          The standard rules for obtaining a KeySym from a KeyPress event
          make use of only the Group 1 and Group 2 KeySyms; no
          interpretation of other KeySyms in the list is given here. (That
          is, the last four KeySyms are unused.)</EM>



<P class="column10"><EM class="quote10">
          Which group to use is determined by modifier state. Switching
          between groups is controlled by the KeySym named Mode_switch.</EM>



<P class="column10"><EM class="quote10">
          By attaching that KeySym to some KeyCode and attaching that
          KeyCode to any one of the modifiers Mod1 through Mod5. This
          modifier is called the ``group modifier''. For any KeyCode, Group
          1 is used when the group modifier is off, and Group 2 is used when
          the group modifier is on.</EM>



<P class="column10"><EM class="quote10">
          Within a group, which KeySym to use is also determined by modifier
          state. The first KeySym is used when the Shift and Lock modifiers
          are off. The second KeySym is used when the Shift modifier is on,
          or when the Lock modifier is on and the second KeySym is uppercase
          alphabetic, or when the Lock modifier is on and is interpreted as
          ShiftLock. Otherwise, when the Lock modifier is on and is
          interpreted as CapsLock, the state of the Shift modifier is
          applied first to select a KeySym, but if that KeySym is lowercase
          alphabetic, then the corresponding uppercase KeySym is used
          instead.</EM>



<P class="column9"><STRONG>
         THE MODIFIER MAPPING</STRONG>



<P class="column9"><STRONG>
         The following description is from the InterClient Communications
         Conventions Manual:</STRONG>
<BR>


<P class="column10"><EM class="quote10">
          X11 supports 8 modifier bits, of which 3 are pre-assigned to
          Shift, Lock and Control. Each modifier bit is controlled by the
          state of a set of keys, and these sets are specified in a table
          accessed by GetModifierMapping() and SetModifierMapping().</EM>



<P class="column10"><EM class="quote10">
          A client needing to use one of the pre-assigned modifiers should
          assume that the modifier table has been set up correctly to
          control these modifiers. The Lock modifier should be interpreted
          as Caps Lock or Shift Lock according as the keycodes in its
          controlling set include XK_Caps_Lock or XK_Shift_Lock.</EM>



<P class="column10"><EM class="quote10">
          Clients should determine the meaning of a modifier bit from the
          keysyms being used to control it.</EM>



<P class="column10"><EM class="quote10">
          A client needing to use an extra modifier, for example Meta,
          should:</EM>



<PRE class="code">
      Scan the existing modifier mappings. If it finds a modifier
      that contains a keycode whose set of keysyms includes XK_Meta_L
      or XK_Meta_R, it should use that modifier bit.

      If there is no existing modifier controlled by XK_Meta_L or
      XK_Meta_R, it should select an unused modifier bit (one with an
      empty controlling set) and:

        If there is a keycode with XL_Meta_L in its set of keysyms,
        add that keycode to the set for the chosen modifier, then

        if there is a keycode with XL_Meta_R in its set of keysyms,
        add that keycode to the set for the chosen modifier, then

        if the controlling set is still empty, interact with the user
        to select one or more keys to be Meta.

      If there are no unused modifier bits, ask the user to take
      corrective action.
</PRE>


<P class="column10"><EM class="quote10">
          This means that the Mod1 modifier does not necessarily mean
          Meta, although some applications (such as twm and emacs 18)
          assume that. Any of the five unassigned modifier bits could
          mean Meta; what matters is that a modifier bit is generated by
          a keycode which is bound to the keysym Meta_L or Meta_R.</EM>



<P class="column10"><EM class="quote10">
          Therefore, if you want to make a <SAMP class="word">`meta</SAMP>' key, the right way is
          to make the keycode in question generate both a Meta keysym,
          and some previously-unassigned modifier bit.</EM>



</P>
  <A name="example_ndash_xmodmap_for_select" id="example_ndash_xmodmap_for_select"></A>
  <H2>
      9.3 Example &ndash; xmodmap for select and kp-f1
      
  </H2>





<P class="column10"><EM class="quote10">
          By Yigal Hochberg <EM><A HREF="mailto:hochberg@cisco.com" >hochberg@cisco.com</A></EM></EM>



<P class="column8">
        In my emacs the <SAMP class="word">select</SAMP> and <SAMP class="word">kp-f1</SAMP> produced same keycode symbol
        when investigated with C-h l lossage buffer. But here is a trick
        how you can get emacs to see them as separate keys.


<PRE class="code">
      % xmodmap -e 'keycode 51 = Select  '
      % xmodmap -e 'keycode 73 = Execute '
      % xmodmap -e 'keycode 125 = KP_F1  '

</PRE>


<P class="column8">
        And in my emacs I can now do:


<PRE class="code">
      ;; Insert (6 block)
      ;; Help (upper left corner)
      ;;
      (global-set-key [(select)] 'other-window)
      (global-set-key [(kp-f1)] 'help-for-help)
</PRE>


</P>
  <A name="example_ndash_sun_keyboard_xmodamp" id="example_ndash_sun_keyboard_xmodamp"></A>
  <H2>
      9.4 Example &ndash; sun keyboard xmodamp
      
  </H2>





<P class="column10"><EM class="quote10">
          <EM><A HREF="mailto:pogrell@informatik.hu-berlin.de" >pogrell@informatik.hu-berlin.de</A></EM> (Lutz Pogrell),</EM>



<P class="column8">
        This discussion really belongs to comp.windows.x, but...  read the
        ICCCM, the Inter Client Communication Conventions Manual. There,
        the propper way of interpreting modifiers is explained. emacs now
        follows those rules(I think). The example given before isn't verry
        helpful. I will explain my xmodmap setting for a sun keyboard (a
        few hex key codes are used, which are system specific):


<PRE class="code">
      !-----------------------------------------
      ! First section:
      !
      ! Let Compose be another Control Key
      ! this is practical for touch typists
      keysym 0xff20 = Control_R
      !
      ! Swap Caps_Lock and Control_L
      !
      remove Lock = Caps_Lock
      remove Control = Control_L
      keysym Control_L = Caps_Lock
      keysym Caps_Lock = Control_L
      add Lock = Caps_Lock
      add Control = Control_L Control_R
      !
      ! now the keys labeled ``Caps Lock'' and ``Compose'' mean Control
      ! and ``Control'' is Caps Lock
      !
      ! Second section:
      !
      ! set up for umlauts
      ! the key labeled ``Alt Graph'' activates the 3th and 4th
      ! level of keys
      ! You may use any four different symbols on any key
      !
      keycode 20 = Mode_switch
      add mod5 = Mode_switch
      keysym a = a A adiaeresis Adiaeresis
      keysym o = o O odiaeresis Odiaeresis
      keysym u = u U udiaeresis Udiaeresis
      keysym s = s S ssharp
      !
      ! Third section:
      !
      ! make ALT and META modifier independent
      !
      remove mod1 = Meta_L
      remove mod1 = Meta_R
      add mod1 = Alt_L
      add mod2 = Meta_L
      add mod2 = Meta_R
      !
      ! now the key labeled ``Alt'' is the Alt modifier and
      ! the keys labeled by a diamond are Meta modifiers
      ! this is especially useful if You use mwm and emacs together---You
      ! may cycle through the windows by &lt;Alt-TAB&gt; and still
      ! use &lt;Meta-TAB&gt; for emacs completion
      -------------------------------------------
</PRE>


<P class="column8">
        The advantage of using xmodmap for setting 8 bit charecter input
        over emacs' iso-accents-mode is that this is the same for all
        clients (or should be the same ...)


<P class="column8">
        The disadvantage is that I don't know an intuitive way of using 3
        different accents with the same letter as in french. Note that
        there are input methods for exactly this reason in X11R6---but I
        don't know what emacs thinks about this concept.


<P class="column8">
        So my modifiers look like this:


<PRE class="code">
      bruno% xmodmap -pm
      xmodmap:  up to 2 keys per modifier, (keycodes in parentheses):

      shift       Shift_L (0x6a),  Shift_R (0x75)
      lock        Caps_Lock (0x53)
      control     Control_L (0x7e),  Control_R (0x4a)
      mod1        Alt_L (0x1a)
      mod2        Meta_L (0x7f),  Meta_R (0x81)
      mod3
      mod4
      mod5        Mode_switch (0x14)
</PRE>


<P class="column8">
        As You can see I use 6 (six) different modifiers.


<P class="column8">
        Was it in the emacs FAQ or in the jargon file where such keyboards
        where called space cadet keyboards?


</P>
  <A name="example_ndash_remap_the_control" id="example_ndash_remap_the_control"></A>
  <H2>
      9.5 Example &ndash; remap the control key
      
  </H2>





<P class="column10"><EM class="quote10">
          how to remap the control key to live above the shift key and
          either get rid of caps lock entirely or move it below the shift
          key.</EM>



<P class="column7"><EM><STRONG>
       9.5.1 Martin Steppler <EM><A HREF="mailto:steppler@comnets.rwth-aachen.de" >steppler@comnets.rwth-aachen.de</A></EM></STRONG></EM>



<P class="column8">
        man xmodmap says:


<P class="column10"><EM class="quote10">
          One of the more irritating differences between keyboards is
          the location of the Control and Shift Lock keys. A common use
          of xmodmap is to swap these two keys as fol- lows:</EM>



<PRE class="code">
      !
      ! Swap Caps_Lock and Control_L
      !
      remove Lock = Caps_Lock
      remove Control = Control_L
      keysym Control_L = Caps_Lock
      keysym Caps_Lock = Control_L
      add Lock = Caps_Lock
      add Control = Control_L
</PRE>

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="code"  id="code"></A>
               <H1>
               10.0 Code
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="perl_code_to_remap_metamodeswitch" id="perl_code_to_remap_metamodeswitch"></A>
  <H2>
      10.1 Perl code to remap Meta-Modeswitch
      
  </H2>




        This code is from  Steffen Risser &lt;c0033016@rzsrv2.rz.tu-bs.de&gt;
        1 Dec 1997 where he used it to map several people's HP-UX
        to the &quot;standard&quot; key configuration. See if you find it usefull.



<PRE class="code">
      #!/usr/bin/perl
      # Searches xmodmap for keysyms Alt_l, Alt_r or Meta_l, Meta_r
      # and exchanges them to Alt_l Meta_l ( mod1 ), Modeswitch ( mod2 ).
      # s.risser@tu-bs.de
      # Version 0.1a

      # the xmodmap binary
      #
      $XMODMAP    = &quot;xmodmap&quot;;

      # set the verbose level ( 1=verbose, 0=nothing )
      #
      $verbose    =1;

      #----------------------------------
      $ALTL   =&quot;$XMODMAP -pke | grep Alt_L&quot;;
      $ALTR   =&quot;$XMODMAP -pke | grep Alt_R&quot;;
      $METAR  =&quot;$XMODMAP -pke | grep Meta_R&quot;;
      $METAL  =&quot;$XMODMAP -pke | grep Meta_L&quot;;

      sub set_mod
      {
          local($mod,$keysym) = @_;
          local($execstr)     = 0;

          $execstr            = &quot;$XMODMAP -e 'clear $mod'&quot;;
          if($verbose) { print &quot;$execstr\n&quot;; }
          system $execstr;

          $execstr            = &quot;$XMODMAP -e 'add $mod = $keysym'&quot;;
          if($verbose) { print &quot;$execstr\n&quot;; }
          system $execstr;
      }

      sub set_keycode
      {
          local($keycode,$keysym) = @_;
          local($execstr)         = &quot;$XMODMAP -e '$keycode = $keysym'&quot;;
           if($verbose) { print &quot;$execstr\n&quot;; }
          system $execstr;
      }

      if($verbose) { print &quot;looking for Alt_L,Alt_R&quot;; };

      ($keycode_l,$keysym_l) = split('=',`$ALTL`);
      ($keycode_r,$keysym_r) = split('=',`$ALTR`);

      chop $keysym_r; chop $keysym_l;

      if ( ! ($keycode_l &amp;&amp; $keycode_r) )
      {
          if($verbose) { print &quot; no\nlooking for Meta_L,Meta_R&quot;; };

          ($keycode_l,$keysym_l) = split('=',`$METAL`);
          ($keycode_r,$keysym_r) = split('=',`$METAR`);

          chop $keysym_r; chop $keysym_l;
      }

      if($keycode_l &amp;&amp; $keycode_r )
      {
          print &quot; yes\n&quot;;
          &amp;set_keycode($keycode_l,&quot;Alt_L Meta_L&quot;);
          &amp;set_keycode($keycode_r,&quot;Mode_switch&quot;);
          &amp;set_mod(&quot;Mod1&quot;,&quot;Alt_L&quot;);
          &amp;set_mod(&quot;Mod2&quot;,&quot;Mode_switch&quot;);
      }
      else
      {
          print &quot; no\n&quot;;
      }
</PRE>

</P>
           </BLOCKQUOTE>
           <HR>
               <A name="case_study_ndash_connection_to"  id="case_study_ndash_connection_to"></A>
               <H1>
               11.0 CASE STUDY &ndash; Connection to remote emacs through Xterm
               
               </H1>
           <BLOCKQUOTE>


</P>
  <A name="foreword" id="foreword"></A>
  <H2>
      11.1 Foreword
      
  </H2>




        I was accessing my university's machine from my work machine. I was
        sitting next to my X-tube and making telnet connection through
        normal xterm. The window was identified as &quot;vt100&quot; in remote site,
        but since it was actually running xterm to me, I gave following
        command to make it recognize right width and hight of the window.


<PRE class="code">
      % eval `resize`
</PRE>


<P class="column8">
        I couldn't open emacs as &quot;windowed&quot; to my work's X-tube, because
        the access rights didn't permit taking any connection <EM class="word">from</EM>
        outside world. I could only &quot;talk&quot; outwards from my work machine,
        not towards it. The setenv DISPLAY my.host.com:0.0 trick was
        therefore useless.


</P>
  <A name="the_connection_does_not_know" id="the_connection_does_not_know"></A>
  <H2>
      11.2 The connection does not know my keyboard
      
  </H2>




        When I opened my emacs, it started fine in a xterm box, but when I
        tried to use my favourite key bindings I quickly noticed, that the
        X- environment extensions that allowed interpreting Ctrl-Fkey
        etc. combinations, were gone. Neither did Alt-shift-keys work any
        longer.


<P class="column8">
        I felt that I was crippled, because Ctrl and Alt keys were out of
        use in this session. So many handy key combinations had vanished.
        The problem was, that through telnet connection, it is not possible
        to send Ctrl-F2 information, because such key does not exist in
        regular [78]bit ascii charts. The motif (X in general) use extra
        events that tell &quot;user pressed Ctrl + some other normal chars&quot;. The
        connection can only base ascii chart characters.


<P class="column8">
        One solution to this problem is that we do a little translation
        while we're talking to remote host:


<PRE class="code">
      Ctrl-F2  | translate in xterm --&gt; send sequence --&gt; remote host
</PRE>


<P class="column8">
        This says that &quot;when user presses Ctrl-F2, the xterm translates the
        sequence into some other key combinations that can be sent over the
        connection. The remote host then sees these sent characters and
        executes them as usual.&quot;


</P>
  <A name="how_do_i_know_what" id="how_do_i_know_what"></A>
  <H2>
      11.3 How do I know what a key produces (ascii sequences?)
      
  </H2>




        The od(1) has ability to record keys and print their <STRONG class="word">true</STRONG>
        nature. Let's find out what the F2 and C-F2 keys produces in our
        environment. ('-t' for keys and 'a' for char output )


<PRE class="code">
      % od -ta
</PRE>


<P class="column8">
        Now od(1) is waiting for input: press keys below. The 'x' is
        used to separate the keys.


<PRE class="code">
      &quot;x&quot; &quot;F2&quot; &quot;x&quot; &quot;Ctrl-F2&quot; &quot;x&quot;
</PRE>


<P class="column8">
        Now press Ctrl-d twice, which terminates the od(1) and it spits
        out the codes:


<PRE class="code">
      0000000    x esc   [   1   3   ~   x esc   [   1   3   ~   x
                   ^^^^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^^^^^^
                   F2                      ctrl-F2
</PRE>


<P class="column8">
        It's quite obvious to see, that the Ctrl key can't be
        distinguished. Anyway, now you know how the F2 is intepreted by
        normal terminals and what codes are sent in telnet connections.


<P class="column8">
        <STRONG class="word">Note</STRONG>: The emacs view-lossage function C-h l, can also produce
        similar results, but do not use it in X-window (-nw is fine I
        guess).


<P class="column8">
        The reason is that emacs gets events directly from X-library funcs,
        and when it prints the results, you may assume that the keycode
        exists. When you use od(1) instead, you're guaranteed to have
        <EM class="word">plain</EM> keyboard read out without any X-events. If Emacs says &quot;yes&quot;
        for the key, and od(1) produces nothing, you should assume that
        emacs got the event through X-libs.


<P class="column8">
        For example If I press Alt-backspace in od(1)


<PRE class="code">
      % od -ta
      0000000
</PRE>


<P class="column8">
        Nothing happens, I can press Alt-basckpace untill I'm tired and
        still, the od is waiting for input. I have to terminate it with
        C-d. If I do same in the emacs: press the Alt-Backspace and
        immediately look at the lossage C-h l, it tells me:


<PRE class="code">
      M-backspace
</PRE>


<P class="column8">
        Why my Alt-key is seen as &quot;Meta&quot; is due to xmodmap(1). Let's jump
        to it in next sections for a while.


</P>
  <A name="short_xmodmap1_glimpse" id="short_xmodmap1_glimpse"></A>
  <H2>
      11.4 Short xmodmap(1) glimpse
      
  </H2>




        The xmodmap(1) tells you how programs see your hardware keys, the
        definition of the entries are quite simple. Eg. My map shows:


<PRE class="code">
      shift       Shift_R (0xc),  Shift_L (0xd)
      lock        Caps_Lock (0x37)
      control     Control_R (0x8),  Control_L (0xe)
      mod1        Meta_R (0xa),  Meta_L (0xb),  Mode_switch (0x36)
      mod2
      mod3
      mod4
      mod5
</PRE>


<P class="column8">
        Look at row 3: it says that whenever I press Right control key or
        Left control key, it produces only &quot;control&quot; to the existing
        programs. (unless they use X-events directly of course)


<P class="column8">
        Generally it's not the best idea to change your xmodmap, just
        because you want remap some key in emacs. The reason is quite
        obvious, when you change the xmodmap, it affects everything. All
        other programs you're running too. If you only redefine some unused
        keys that you plan to use only in emacs, then you can play with
        xmodmap safely. Next we peek X events little more closely.


</P>
  <A name="xev_ndash_spot_your_xeventskeys" id="xev_ndash_spot_your_xeventskeys"></A>
  <H2>
      11.5 Xev &ndash; Spot your X-events(keys) easily
      
  </H2>




        This 'xev' program is Distributed with X11R5 (or any X-dist.). When
        you run it, it'll open a window which starts reading any events you
        generate: moving mouse, clicking, pressing shift,
        alt... Eg. pressing Alt gives:


<PRE class="code">
      [when pressed]
      KeyPress event, serial 18, synthetic NO, window 0x6000001,
          root 0x23, subw 0x0, time 1671998966, (85,130), root:(580,559),
          state 0x0, keycode 11 (keysym 0xffe7, Meta_L), same_screen YES,
          XLookupString gives 0 characters:  &quot;&quot;

      keycode 11        == Physical keyboad key
      keysym Meta_L     == physical key to &quot;logical&quot; X-key.


      [when released]
      KeyRelease event, serial 20, synthetic NO, window 0x6000001,
          root 0x23, subw 0x0, time 1672001116, (85,130), root:(580,559),
          state 0x8, keycode 11 (keysym 0xffe7, Meta_L), same_screen YES,
          XLookupString gives 0 characters:  &quot;&quot;
</PRE>


<P class="column8">
        So use this if you want to find out how the event is &quot;seen&quot; by
        motif windowing system.


</P>
  <A name="xterms_xrm_switch_for_key" id="xterms_xrm_switch_for_key"></A>
  <H2>
      11.6 Xterm's -xrm switch for key settings, where are the key names?
      
  </H2>




        We're going to program Xterm soon, so you you must learn to find
        your symbolic key names: they are located along the Xlib path,
        similar to mine:


<PRE class="code">
      /usr/include/X11R5/X11/keysymdef.h
</PRE>


<P class="column8">
        Drop the &quot;XK_&quot; prefixes when using the names in Xterm's -xrm
        switch. A excerpt of the keysymdef.h file:


<PRE class="code">
      /* Cursor control &amp; motion */

      #define XK_Home   0xFF50
      #define XK_Left   0xFF51  /* Move left, left arrow */
      #define XK_Up     0xFF52  /* Move up, up arrow */
      #define XK_Right  0xFF53  /* Move right, right arrow */
      #define XK_Down   0xFF54  /* Move down, down arrow */
      #define XK_Prior  0xFF55  /* Prior, previous */
      #define XK_Next   0xFF56  /* Next */
      #define XK_End    0xFF57  /* EOL */
      #define XK_Begin  0xFF58  /* BOL */
</PRE>


</P>
  <A name="custom_xterm_ndash_making_xterm" id="custom_xterm_ndash_making_xterm"></A>
  <H2>
      11.7 Custom xterm &ndash; making xterm to translate character for connection
      
  </H2>




        Xterm can accept regular motif commands, so let's use its -xrm
        switch to &quot;program&quot; it. This little shell file launches up
        specially configured xterm session: it converts pressed keys to
        another key sequences.


<PRE class="code">
      #!/bin/sh
      # @(#) file:  xtu &ndash;  (Xt)erm to (U)niversity
      # @(#) desc:  Special key config for remote emacs through telnet
      #
      exec xterm -xrm 'XTerm.VT100.translations: #override \
        Ctrl ~Meta ~Shift &lt;Key&gt; F2: string(0x14) string(&quot;Cf2&quot;) \n\
              '\
              $*

      0x14  = Control-t code, see ascii chart
      Cf2   = string of single keystrokes
</PRE>


<P class="column8">
        It says that &quot;When user presses C-F2 in this Xterm, turn it into
        key sequence 'C-t Cf2' &quot;


</P>
  <A name="remote_emacs_setup" id="remote_emacs_setup"></A>
  <H2>
      11.8 Remote emacs setup
      
  </H2>




        Now I can pass the C-F2 to my university's machine by using special
        xterm. Now I have to set up target emacs so, that it can understand
        these new key sequences. The &quot;C-t&quot; was just an example of a
        possible prefix-key, you can select any other prefix key. I use
        same ~/.emacs.keys file for both machines, but the lisp code can
        snoop if the current emacs is <EM class="word">X-telnetting</EM> and not run from
        regular term. See the lisp code later.


<P class="column8">
        First, we add this into ~/.cshrc. It defines environment variable
        <EM class="word">LOGIN_SITE</EM> when we log to account from outside the University
        site. My account in University is 'ssjaaa': (S)ociology (S)tudies
        (Ja)ri (Aa)lto.


<PRE class="code">
      # ........................... setting right terminal ...
      #   NOTE: This is SunOS machine's .cshrc and the output of who(1)
      #         etc. commands may vary in another systems.
      #
      #   tty gives us &quot;/dev/pts/17&quot;, drop that &quot;/dev/&quot; away....
      set data = `tty`; set tty = &quot;pts/$data:t&quot;

      #   now, where are we logged from  ?
      #   &quot;ssjaaa - pts/17 Sep 29 18:58 . 18523 (aapo.tele.nokia.fi)&quot;
      #
      set who  = (`who -a | grep $USER| grep $tty`)

      # get last element &quot;(aapo.tele.nokia.fi)&quot;
      #
      set site = $who[$#who]

      # Underscore for my private vars.
      #
      setenv _LOGIN_SITE $site

      #
      #  End file

</PRE>


<P class="column8">
        In Emacs; you can now check the environment variable


<PRE class="code">
      (getenv &quot;_LOGIN_SITE&quot;)
</PRE>


<P class="column8">
        Which should reveal if you're connected from some remote host.
        You can then determine if you're running Xterm+telnet+Emacs.


<P class="column8">
        We also redefine key bindings in emacs to accept &quot;C-t Cf2&quot; as C-F2
        The F2 is seen direcly: try it and you'll see something like
        following in remote emacs's lossage buffer, <SAMP class="word">M-x</SAMP> <SAMP class="word">view-lossage</SAMP>


<PRE class="code">
      esc [ 1 3 ~
</PRE>


</P>
  <A name="testing_the_special_xterm_and" id="testing_the_special_xterm_and"></A>
  <H2>
      11.9 Testing the special Xterm and remote emacs co-operation
      
  </H2>




        Before we do telnet, we can test the configuration in X Start xtu
        shell script. If you made mistakes in in -xrm commands, it says:


<PRE class="code">
      Warning: translation table syntax error: Unknown keysym name: f2
      Warning: ... found while parsing 'Ctrl ~Meta ~Shift &lt;Key&gt; f2:
               string(0x14) string(&quot;Cf2&quot;)      '
</PRE>


<P class="column8">
        You have to write symbolic key names with proper case, here the
        mistake is 'f2' when it should have been 'F2'. Use xev or refer to
        keysymdef.h for proper names. Start od(1) in the Xterm just
        appeared to check that the C-F2 is translated correctly.


<PRE class="code">
      % od -ta
      Cf2      < should appear if you press C-F2
</PRE>


<P class="column8">
        If od(1) test succeeds, start emacs for final test


<PRE class="code">
      % emacs -nw -debug-init < in X, force it to window.
</PRE>


<P class="column8">
        If the lisp code added doesn't signal any errors, then you can try
        out the key F2. Press it and following text should appear in
        buffer:


<PRE class="code">
      &quot;hello&quot;
</PRE>


<P class="column8">
        If all went ok, your modified Xterm works correcly. You can use the
        same keys as you used in X, althought the remote emacs does not
        know anything about X. That's what I call transparency. Remember to
        modify your ~/.cshrc and add the lisp code to the remote
        ~/.emacs. There is shadow.el in 19.28 std distrib, that can mirror
        your files easily to other sites, like your shared ~/.emacs and
        ~/.cshrc in this case.


<P class="column8">
        Now you know all you need and you can start defining more keys that
        can't be sent directly via wire. My complete setup is attached
        below.


</P>
  <A name="complete_live_setup_ndash_modify" id="complete_live_setup_ndash_modify"></A>
  <H2>
      11.10 Complete, live, setup &ndash; Modify to personal needs
      
  </H2>




        Offered &quot;as is&quot;, no code will be explained via email. Peter von
        der Ahe <EM><A HREF="mailto:pahe@daimi.aau.dk" >pahe@daimi.aau.dk</A></EM> kindly sent more Bindings to &quot;xte&quot;
        script. All the string(0x1b) codes that enable M-&gt; and M-&lt; are
        from him.


<P class="column9"><STRONG>
         Please note that the code below may not display correcly
         in html layout. Read the code from the text version.</STRONG>


  ;;; --++-- --++-- --++-- --++-- --++-- --++-- --++-- --++- .emacs.keys.el --


  (require 'tinylib)

  ;; Define backspace key for non-window Emacs.
  ;;
  (cond
   ((ti::xe-window-system)
    (setq key-translation-map (make-sparse-keymap))
    (define-key key-translation-map &quot;\177&quot; &quot;\C-h&quot;)
    (define-key key-translation-map &quot;\C-h&quot; &quot;\177&quot;)
    (defvar BACKSPACE &quot;\177&quot;)
    (defvar DELETE    &quot;\C-h&quot;)
    (global-set-key BACKSPACE 'backward-delete-char)
    )



  (define-in-function-keymap
   '(
     ([?\e ?O ?I]  [tab])   ;; This is KP_Tab X key symbol
     ([kp_tab] [tab])


<P class="column5">
     ;;  Those horrible terminals that send this crispix language...
     ;;  Usually when I'm running non-windowed through xterm and telnet
     ;;
     ([?\e ?O ?A] [up])
     ([?\e ?O ?B] [down])
     ([?\e ?O ?C] [right])
     ([?\e ?O ?D] [left])
     ([?\e ?O ?D] [left])


<P class="column4">
    ([?\e ?\<SPAN class="super"> ?2 ?~</SPAN>  [insert])
    ([?\e ?\<SPAN class="super"> ?5 ?~</SPAN>  [next])
    ([?\e ?\<SPAN class="super"> ?6 ?~</SPAN>  [prior])


<P class="column4">
    ([?\e ?O ?\C-@]  [end])



<P class="column4">
    ([?\e ?\<SPAN class="super">  ?1 ?1 ?~</SPAN>  [f1])
    ([?\e ?\<SPAN class="super">  ?1 ?2 ?~</SPAN>  [f2])
    ([?\e ?\<SPAN class="super">  ?1 ?3 ?~</SPAN>  [f3])
    ([?\e ?\<SPAN class="super">  ?1 ?4 ?~</SPAN>  [f4])
    ([?\e ?\<SPAN class="super">  ?1 ?5 ?~</SPAN>  [f5])
    ([?\e ?\<SPAN class="super">  ?1 ?6 ?~</SPAN>  [f6])
    ([?\e ?\<SPAN class="super">  ?1 ?7 ?~</SPAN>  [f7])
    ([?\e ?\<SPAN class="super">  ?1 ?8 ?~</SPAN>  [f8])
    ([?\e ?\<SPAN class="super">  ?1 ?9 ?~</SPAN>  [f9])
    ))


  (defun my-special-xterm ()
    &quot;Accept special keysequences sent by Xterm. Prefix map C-t used.
  You must run 'xte' shell script that sets up Xterm to send these
  keycodes.&quot;


<P class="column4">
    (interactive)
    ;; C-t = my translate map, make it available for us
    ;;
    (global-unset-key &quot;\C-t&quot;)           ;was transpose-chars

 ;; We translate the special key sequences back to key events.
 ;; Modifiers C = Ctrl, A = Alt, S = Shift
 ;;
 ;; ............................................................ #tab ...
 ;;
 (define-in-function-keymap
  '(
  ([?\C-t ?C ?k ?t] [C-tab])
  ([?\C-t ?S ?k ?t] [S-tab])
  ([?\C-t ?A ?k ?t] [A-tab])

  ([?\C-t ?C ?S ?k ?t] [C-S-tab])
  ([?\C-t ?A ?S ?k ?t] [A-S-tab])
  ([?\C-t ?A ?C ?k ?t] [A-C-tab])

  ([?\C-t ?A ?C ?S ?k ?t] [A-C-S-tab])
  ))

 ;; ......................................................... #return ...
 ;;
 (define-in-function-keymap)
 '(
  ([?\C-t ?C ?k ?r] [C-return])
  ([?\C-t ?S ?k ?r] [S-return])
  ([?\C-t ?A ?k ?r] [A-return])

  ([?\C-t ?C ?S ?k ?r] [C-S-return])
  ([?\C-t ?A ?S ?k ?r] [A-S-return])
  ([?\C-t ?A ?C ?k ?r] [A-C-return])

  ([?\C-t ?A ?C ?S ?k ?r] [A-C-S-return])
  ))


 ;; ...................................................... #backspace ...
 ;;
 (define-in-function-keymap)
 '(
  ([?\C-t ?C ?k ?b] [C-backspace])
  ([?\C-t ?S ?k ?b] [S-backspace])
  ([?\C-t ?A ?k ?b] [A-backspace])

  ([?\C-t ?C ?S ?k ?b] [C-S-backspace])
  ([?\C-t ?A ?S ?k ?b] [A-S-backspace])
  ([?\C-t ?A ?C ?k ?b] [A-C-backspace])

  ([?\C-t ?C ?A ?S ?k ?b] [A-C-S-backspace])
  ))


 ;; ........................................................... #page ...
 ;; ?P = page group keys
 ;;  u = pgup, d = pgdown, e = end, h = home, i=insert, d=delete
 ;;
 (define-in-function-keymap)
 '(

  ([?\C-t ?C ?P ?g ?d] [C-next])
  ([?\C-t ?S ?P ?g ?d] [S-next])
  ([?\C-t ?A ?P ?g ?d] [A-next])

  ([?\C-t ?C ?S ?P ?g ?d] [C-S-next])
  ([?\C-t ?A ?S ?P ?g ?d] [A-S-next])
  ([?\C-t ?A ?C ?P ?g ?d] [A-C-next])

  ([?\C-t ?C ?A ?S ?P ?g ?d] [A-C-S-next])



  ([?\C-t ?C ?P ?g ?u] [C-prior])
  ([?\C-t ?S ?P ?g ?u] [S-prior])
  ([?\C-t ?A ?P ?g ?u] [A-prior])

  ([?\C-t ?C ?S ?P ?g ?u] [C-S-prior])
  ([?\C-t ?A ?S ?P ?g ?u] [A-S-prior])
  ([?\C-t ?A ?C ?P ?g ?u] [A-C-prior])

  ([?\C-t ?C ?A ?S ?P ?g ?u] [A-C-S-prior])


  ([?\C-t ?C ?P ?h] [C-home])
  ([?\C-t ?S ?P ?h] [S-home])
  ([?\C-t ?A ?P ?h] [A-home])

  ([?\C-t ?C ?S ?P ?h] [C-S-home])
  ([?\C-t ?A ?S ?P ?h] [A-S-home])
  ([?\C-t ?A ?C ?P ?h] [A-C-home])

  ([?\C-t ?C ?A ?S ?P ?h] [A-C-S-home])


  ([?\C-t ?C ?P ?e] [C-select])
  ([?\C-t ?S ?P ?e] [S-select])
  ([?\C-t ?A ?P ?e] [A-select])

  ([?\C-t ?C ?S ?P ?e] [C-S-select])
  ([?\C-t ?A ?S ?P ?e] [A-S-select])
  ([?\C-t ?A ?C ?P ?e] [A-C-select])

  ([?\C-t ?C ?A ?S ?P ?e] [A-C-S-select])



  ([?\C-t ?C ?P ?i] [C-insert])
  ([?\C-t ?S ?P ?i] [S-insert])
  ([?\C-t ?A ?P ?i] [A-insert])

  ([?\C-t ?C ?S ?P ?i] [C-S-insert])
  ([?\C-t ?A ?S ?P ?i] [A-S-insert])
  ([?\C-t ?A ?C ?P ?i] [A-C-insert])

  ([?\C-t ?C ?A ?S ?P ?i] [A-C-S-insert])



  ([?\C-t ?C ?P ?d] [C-delete])
  ([?\C-t ?S ?P ?d] [S-delete])
  ([?\C-t ?A ?P ?d] [A-delete])

  ([?\C-t ?C ?S ?P ?d] [C-S-delete])
  ([?\C-t ?A ?S ?P ?d] [A-S-delete])
  ([?\C-t ?A ?C ?P ?d] [A-C-delete])

  ([?\C-t ?C ?A ?S ?P ?d] [A-C-S-delete])
  ))


 ;; ....................................................... #movement ...
 ;; ?m = movement map,
 ;;  r = right, l = left, u= up, d = down
 ;;
 (define-in-function-keymap)
 '(

  ([?\C-t ?C ?m ?u] [C-up])
  ([?\C-t ?S ?m ?u] [S-up])
  ([?\C-t ?A ?m ?u] [A-up])

  ([?\C-t ?C ?S ?m ?u] [C-S-up])
  ([?\C-t ?A ?S ?m ?u] [A-S-up])
  ([?\C-t ?A ?C ?m ?u] [A-C-up])

  ([?\C-t ?C ?A ?S ?m ?u] [A-C-S-up])


  ([?\C-t ?C ?m ?d] [C-down])
  ([?\C-t ?S ?m ?d] [S-down])
  ([?\C-t ?A ?m ?d] [A-down])

  ([?\C-t ?C ?S ?m ?d] [C-S-down])
  ([?\C-t ?A ?S ?m ?d] [A-S-down])
  ([?\C-t ?A ?C ?m ?d] [A-C-down])

  ([?\C-t ?C ?A ?S ?m ?d] [A-C-S-down])


  ([?\C-t ?C ?m ?l] [C-left])
  ([?\C-t ?S ?m ?l] [S-left])
  ([?\C-t ?A ?m ?l] [A-left])

  ([?\C-t ?C ?S ?m ?l] [C-S-left])
  ([?\C-t ?A ?S ?m ?l] [A-S-left])
  ([?\C-t ?A ?C ?m ?l] [A-C-left])

  ([?\C-t ?C ?A ?S ?m ?l] [A-C-S-left])


  ([?\C-t ?C ?m ?r] [C-right])
  ([?\C-t ?S ?m ?r] [S-right])
  ([?\C-t ?A ?m ?r] [A-right])

  ([?\C-t ?C ?S ?m ?r] [C-S-right])
  ([?\C-t ?A ?S ?m ?r] [A-S-right])
  ([?\C-t ?A ?C ?m ?r] [A-C-right])

  ([?\C-t ?C ?A ?S ?m ?r] [A-C-S-right])


  ))


 ;; ....................................................... #function ...
 ;;
 (define-in-function-keymap)
 '(
  ([?\C-t ?S ?f ?1] [S-f1])
  ([?\C-t ?S ?f ?2] [S-f2])
  ([?\C-t ?S ?f ?3] [S-f3])
  ([?\C-t ?S ?f ?4] [S-f4])
  ([?\C-t ?S ?f ?5] [S-f5])
  ([?\C-t ?S ?f ?6] [S-f6])
  ([?\C-t ?S ?f ?7] [S-f7])
  ([?\C-t ?S ?f ?8] [S-f8])
  ([?\C-t ?S ?f ?9] [S-f9])
  ([?\C-t ?S ?f ?- ?0] [S-f10])
  ([?\C-t ?S ?f ?- ?1] [S-f11])
  ([?\C-t ?S ?f ?- ?2] [S-f12])

  ([?\C-t ?C ?f ?1] [C-f1])
  ([?\C-t ?C ?f ?2] [C-f2])
  ([?\C-t ?C ?f ?3] [C-f3])
  ([?\C-t ?C ?f ?4] [C-f4])
  ([?\C-t ?C ?f ?5] [C-f5])
  ([?\C-t ?C ?f ?6] [C-f6])
  ([?\C-t ?C ?f ?7] [C-f7])
  ([?\C-t ?C ?f ?8] [C-f8])
  ([?\C-t ?C ?f ?9] [C-f9])
  ([?\C-t ?C ?f ?- ?0] [C-f10])
  ([?\C-t ?C ?f ?- ?1] [C-f11])
  ([?\C-t ?C ?f ?- ?2] [C-f12])
  ))

 )

  (my-special-xterm)


  ;;; --++-- --++-- --++-- --++-- --++-- --++-- --++-- --++-- --++-- xte --

  #! /bin/sh
  #
  # @(#) file:  xte &ndash;  (Xt)erm for telnet and remote (E)macs
  # @(#) desc:  Special key configuration for remote emacs through telnet
  #
  # $Contactid: <EM><A HREF="mailto:jari.aalto@poboxes.com" >jari.aalto@poboxes.com</A></EM> $


  #  Special Xterm, which translates HP-UX keys which are seen in
  #  X-env to some prefix keys over the telnet connection to
  #  remote Emacs
  #
  #  See
  #    % od -ta
  #
  #  The X-keys are defined in
  #
  #     /usr/include/X11R5/X11/keysymdef.h
  #
  #  Just leave the &quot;XK_&quot; away from the name definition. Eg.
  #
  #    #define XK_BackSpace            0xFF08
  #
  #  ?\C-t = 20dec, 14h, Ctrl-t
  #
  #  Use 'xev' to read the X-events
  #
  #  Use 'xmodmap -pm' to see what keys are translated to which
  #       LEFT     translations
  #       ^^^      ^^^^
  #       seen as  real xevents
  #
  # ~ refers to not()  operator
  #
  # Not accessible
  #
  #   Alt(meta){tab} is never produced, although it's presented here
  #   Alt{up,down}   is never produced ..
  #
  # Not X11 keysymdef.h, examined with xev
  #
  #   HpInsertChar, HpDeleteChar, ccedilla, aring, cent
  #   --&gt; unforunately direct Alt keys cannot be mapped
  #
  # F-keys
  #
  #   F1 .. F12 can be sent directly, but Shift, Ctrl, Alt don't
  #
  # Title
  #
  #   XT.E  = Xterm for remote Emacs
  #



 exec xterm -T &quot;XT.E&quot; -xrm 'XTerm.VT100.translations: #override \
 \
 ~Ctrl ~Meta ~Shift &lt;Key&gt; KP_Tab:     string(0x9)                     \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; Tab:        string(0x14) string(&quot;Ckt&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Tab:        string(0x14) string(&quot;Skt&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Tab:        string(0x14) string(&quot;ASkt&quot;)     \n\
 \
  Ctrl ~Meta ~Shift &lt;Key&gt; Return:     string(0x14) string(&quot;Ckr&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Return:     string(0x14) string(&quot;Skr&quot;)      \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; Return:     string(0x14) string(&quot;Akr&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Return:     string(0x14) string(&quot;CSkr&quot;)     \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; Return:     string(0x14) string(&quot;ASkr&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; Return:     string(0x14) string(&quot;ACkr&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; Return:     string(0x14) string(&quot;ACSkr&quot;)    \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; BackSpace:  string(0x14) string(&quot;Ckb&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; BackSpace:  string(0x14) string(&quot;Skb&quot;)      \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; BackSpace:  string(0x14) string(&quot;Akb&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; BackSpace:  string(0x14) string(&quot;CSkb&quot;)     \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; BackSpace:  string(0x14) string(&quot;ASkb&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; BackSpace:  string(0x14) string(&quot;ACkb&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; BackSpace:  string(0x14) string(&quot;ACSkb&quot;)    \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; Prior:      string(0x14) string(&quot;CPgu&quot;)     \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Prior:      string(0x14) string(&quot;SPgu&quot;)     \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; Prior:      string(0x14) string(&quot;APgu&quot;)     \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Prior:      string(0x14) string(&quot;CSPgu&quot;)    \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; Prior:      string(0x14) string(&quot;ASPgu&quot;)    \n\
  Ctrl  Meta ~Shift &lt;Key&gt; Prior:      string(0x14) string(&quot;ACPgu&quot;)    \n\
  Ctrl  Meta  Shift &lt;Key&gt; Prior:      string(0x14) string(&quot;ACSPgu&quot;)   \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; Next:       string(0x14) string(&quot;CPgd&quot;)     \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Next:       string(0x14) string(&quot;SPgd&quot;)     \n\
 ~Ctrl        Meta ~Shift &lt;Key&gt; Next: string(0x14) string(&quot;APgd&quot;)     \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Next:       string(0x14) string(&quot;CSPgd&quot;)    \n\
 ~Ctrl        Meta  Shift &lt;Key&gt; Next: string(0x14) string(&quot;ASPgd&quot;)    \n\
  Ctrl        Meta ~Shift &lt;Key&gt; Next: string(0x14) string(&quot;ACPgd&quot;)    \n\
  Ctrl        Meta  Shift &lt;Key&gt; Next: string(0x14) string(&quot;ACSPgd&quot;)   \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; Home:       string(0x14) string(&quot;CPh&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Home:       string(0x14) string(&quot;SPh&quot;)      \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; Home:       string(0x14) string(&quot;APh&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Home:       string(0x14) string(&quot;CSPh&quot;)     \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; Home:       string(0x14) string(&quot;ASPh&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; Home:       string(0x14) string(&quot;ACPh&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; Home:       string(0x14) string(&quot;ACSPh&quot;)    \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; Select:     string(0x14) string(&quot;CPe&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Select:     string(0x14) string(&quot;SPe&quot;)      \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; Select:     string(0x14) string(&quot;APe&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Select:     string(0x14) string(&quot;CSPe&quot;)     \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; Select:     string(0x14) string(&quot;ASPe&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; Select:     string(0x14) string(&quot;ACPe&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; Select:     string(0x14) string(&quot;ACSPe&quot;)    \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; hpInsertChar: string(0x14) string(&quot;CPi&quot;)    \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; hpInsertChar: string(0x14) string(&quot;SPi&quot;)    \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; hpInsertChar: string(0x14) string(&quot;APi&quot;)    \n\
  Ctrl ~Meta  Shift &lt;Key&gt; hpInsertChar: string(0x14) string(&quot;CSPi&quot;)   \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; hpInsertChar: string(0x14) string(&quot;ASPi&quot;)   \n\
  Ctrl  Meta ~Shift &lt;Key&gt; hpInsertChar: string(0x14) string(&quot;ACPi&quot;)   \n\
  Ctrl  Meta  Shift &lt;Key&gt; hpInsertChar: string(0x14) string(&quot;ACSPi&quot;)  \n\
\
 ~Ctrl ~Meta ~Shift &lt;Key&gt; hpDeleteChar: string(0x14) string(&quot;Pd&quot;)     \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; hpDeleteChar: string(0x14) string(&quot;CPd&quot;)    \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; hpDeleteChar: string(0x14) string(&quot;SPd&quot;)    \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; hpDeleteChar: string(0x14) string(&quot;APd&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; hpDeleteChar: string(0x14) string(&quot;CSPd&quot;)   \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; hpDeleteChar: string(0x14) string(&quot;ASPd&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; hpDeleteChar: string(0x14) string(&quot;ACPd&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; hpDeleteChar: string(0x14) string(&quot;ACSPd&quot;)    \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; Up:         string(0x14) string(&quot;Cmu&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Up:         string(0x14) string(&quot;Smu&quot;)      \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; Up:         string(0x14) string(&quot;Amu&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Up:         string(0x14) string(&quot;CSmu&quot;)     \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; Up:         string(0x14) string(&quot;ASmu&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; Up:         string(0x14) string(&quot;ACmu&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; Up:         string(0x14) string(&quot;ACSmu&quot;)    \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; Down:       string(0x14) string(&quot;Cmd&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Down:       string(0x14) string(&quot;Smd&quot;)      \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; Down:       string(0x14) string(&quot;Amd&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Down:       string(0x14) string(&quot;CSmd&quot;)     \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; Down:       string(0x14) string(&quot;ASmd&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; Down:       string(0x14) string(&quot;ACmd&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; Down:       string(0x14) string(&quot;ACSmd&quot;)    \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; Left:       string(0x14) string(&quot;Cml&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Left:       string(0x14) string(&quot;Sml&quot;)      \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; Left:       string(0x14) string(&quot;Aml&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Left:       string(0x14) string(&quot;CSml&quot;)     \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; Left:       string(0x14) string(&quot;ASml&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; Left:       string(0x14) string(&quot;ACml&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; Left:       string(0x14) string(&quot;ACSml&quot;)    \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; Right:      string(0x14) string(&quot;Cmr&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; Right:      string(0x14) string(&quot;Smr&quot;)      \n\
 ~Ctrl  Meta ~Shift &lt;Key&gt; Right:      string(0x14) string(&quot;Amr&quot;)      \n\
  Ctrl ~Meta  Shift &lt;Key&gt; Right:      string(0x14) string(&quot;CSmr&quot;)     \n\
 ~Ctrl  Meta  Shift &lt;Key&gt; Right:      string(0x14) string(&quot;ASmr&quot;)     \n\
  Ctrl  Meta ~Shift &lt;Key&gt; Right:      string(0x14) string(&quot;ACmr&quot;)     \n\
  Ctrl  Meta  Shift &lt;Key&gt; Right:      string(0x14) string(&quot;ACSmr&quot;)    \n\
\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F1:         string(0x14) string(&quot;Sf1&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F2:         string(0x14) string(&quot;Sf2&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F3:         string(0x14) string(&quot;Sf3&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F4:         string(0x14) string(&quot;Sf4&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F5:         string(0x14) string(&quot;Sf5&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F6:         string(0x14) string(&quot;Sf6&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F7:         string(0x14) string(&quot;Sf7&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F8:         string(0x14) string(&quot;Sf8&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F9:         string(0x14) string(&quot;Df9&quot;)      \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F10:        string(0x14) string(&quot;Sf-0&quot;)     \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F11:        string(0x14) string(&quot;Sf-1&quot;)     \n\
 ~Ctrl ~Meta  Shift &lt;Key&gt; F12:        string(0x14) string(&quot;Sf-2&quot;)     \n\
\
  Ctrl ~Meta ~Shift &lt;Key&gt; F1:         string(0x14) string(&quot;Cf1&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F2:         string(0x14) string(&quot;Cf2&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F3:         string(0x14) string(&quot;Cf3&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F4:         string(0x14) string(&quot;Cf4&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F5:         string(0x14) string(&quot;Cf5&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F6:         string(0x14) string(&quot;Cf6&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F7:         string(0x14) string(&quot;Cf7&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F8:         string(0x14) string(&quot;Cf8&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F9:         string(0x14) string(&quot;Cf9&quot;)      \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F10:        string(0x14) string(&quot;Cf-0&quot;)     \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F11:        string(0x14) string(&quot;Cf-1&quot;)     \n\
  Ctrl ~Meta ~Shift &lt;Key&gt; F12:        string(0x14) string(&quot;Cf-2&quot;)     \n\
\
  ~Ctrl  Meta  Shift &lt;Key&gt; .:            string(0x1b) string(&quot;&gt;&quot;)        \n\
  ~Ctrl  Meta  Shift &lt;Key&gt; comma:        string(0x1b) string(&quot;&lt;&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; space:        string(0x1b) string(&quot; &quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; backslash:    string(0x1b) string(&quot;\\&quot;)       \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; a:            string(0x1b) string(&quot;a&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; b:            string(0x1b) string(&quot;b&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; c:            string(0x1b) string(&quot;c&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; d:            string(0x1b) string(&quot;d&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; e:            string(0x1b) string(&quot;e&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; f:            string(0x1b) string(&quot;f&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; g:            string(0x1b) string(&quot;g&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; h:            string(0x1b) string(&quot;h&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; i:            string(0x1b) string(&quot;i&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; j:            string(0x1b) string(&quot;j&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; k:            string(0x1b) string(&quot;k&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; l:            string(0x1b) string(&quot;l&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; m:            string(0x1b) string(&quot;m&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; n:            string(0x1b) string(&quot;n&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; o:            string(0x1b) string(&quot;o&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; p:            string(0x1b) string(&quot;p&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; q:            string(0x1b) string(&quot;q&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; r:            string(0x1b) string(&quot;r&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; s:            string(0x1b) string(&quot;s&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; t:            string(0x1b) string(&quot;t&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; u:            string(0x1b) string(&quot;u&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; v:            string(0x1b) string(&quot;v&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; w:            string(0x1b) string(&quot;w&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; x:            string(0x1b) string(&quot;x&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; y:            string(0x1b) string(&quot;y&quot;)        \n\
  ~Ctrl  Meta ~Shift &lt;Key&gt; z:            string(0x1b) string(&quot;z&quot;)        \n\
 ' \
 $*

  # ............................................................ end  xtu ...

# ............................................................... &amp;eof ...



<!--    ......................................................................
    DOCUMENT END BLOCK
    ......................................................................
-->

</BLOCKQUOTE>
<HR>
<EM    class="footer">
<P>
Copyright (c) 2002 by Jari Aalto. This material may be
distributed only subject to the terms and conditions set forth
in the Open Publication License, v1.0 or later (the latest
version is presently available at
http://www.opencontent.org/). Distribution of the work
or derivative of the work for commercial purposes in any
form is prohibited unless prior permission is obtained from
the copyright holder. (VI.B LICENSE OPTIONS)
</P>
<P>
This file has been automatically generated from plain text file
with Perl script <STRONG>t2html.pl 2002.0805</STRONG><BR>
Document author: Jari Aalto<BR>
Contact: &lt;<A HREF="mailto:jari.aalto@poboxes.com">jari.aalto@poboxes.com</A>&gt;<BR>
Html date: 2002-08-05 04:24<BR>
</EM    class="footer">
</BODY>
</HTML>
