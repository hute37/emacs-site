#!/usr/local/bin/perl
#
# @(#) perl-function-list.pl -- Grep Perl funtions calls from manual pages.
# @(#) $Id: perl-function-list.pl,v 1.1 2005-12-04 20:58:09 hute37 Exp $
#
#  File id
#
#	.Copyright (C)  2000-2002 <jari.aalto@poboxes.com>
#	.Created:	2000-01
#	.Keywords:	Perl, tiny tools, Java function ripper
#	.Perl:	        5.004
#
#	This program is free software; you can redistribute it and/or
#	modify it under the terms of the GNU General Public License as
#	published by the Free Software Foundation; either version 2 of
#	the License, or (at your option) any later version.
#
#	This program is distributed in the hope that it will be useful, but
#	WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#	General Public License for more details.
#
#	You should have received a copy of the GNU General Public License along
#	with this program; if not, write to the Free Software Foundation,
#	Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#   About program layout
#
#       The {{ }}} marks you see in this file are party of file "fold"
#       conrol package called folding.el (Unix Emacs lisp package).
#       ftp://ftp.csd.uu.se/pub/users/andersl/beta/ to get the latest.
#       There is also lines that look like # ....... &tag ... and they
#       are generated by Emacs Lisp package tinybm.el.
#
#   Funny identifiers at the top of file
#
#       The GNU RCS ident(1) program can print usefull information out
#       of all variables that are in format $ IDENTIFIER: text $
#       See also Unix man pages for command what(1) which outputs all lines
#       matching @( # ). Try commands:
#
#	    % what  PRGNAME
#	    % ident PRGNAME
#
#   Description
#
#	Call program with
#
#	    % perl perl-function-list.pl --help
#
#   End



BEGIN { require 5.004 }

use autouse 'Pod::Text'     => qw( pod2text );

use strict;

use English;
use Env;
use Cwd;
use Getopt::Long;
use File::Basename;
use File::Find;

    use vars qw ( $VERSION );

    #   This is for use of Makefile.PL and ExtUtils::MakeMaker
    #   So that it puts the tardist number in format YYYY.MMDD
    #   The REAL version number is defined later

    #   The following variable is updated by my Emacs setup whenever
    #   this file is saved

    $VERSION = '2001.1213';


# {{{ Initial setup

# ****************************************************************************
#
#   DESCRIPTION
#
#       Set global variables for the program
#
#   INPUT PARAMETERS
#
#	none
#
#   RETURN VALUES
#
#       none
#
# ****************************************************************************

sub Initialize ()
{

    use vars qw
    (
	$debug

	$PROGNAME
	$LIB

	$FILE_ID
	$VERSION
	$CONTACT
	$URL
	$WIN32

	$HOME
	$PATH
	@PATH
    );

    $PROGNAME	= "java-function-list.pl";
    $LIB	= $PROGNAME;
    my $id	= "$LIB.Initialize";

    $FILE_ID  = q$Id: perl-function-list.pl,v 1.1 2005-12-04 20:58:09 hute37 Exp $;
    $VERSION  = (split (' ', $FILE_ID))[2];
    $CONTACT  = "<jari.aalto\@poboxes.com>";
    $URL      = "http://tiny-tools.sourceforge.net/";
    $WIN32    = 1   if  $OSNAME =~ /win32/i;

    $OUTPUT_AUTOFLUSH = 1;

    if ( not -e $HOME or  $HOME eq '' )
    {
	die "$id: HOME not set";
    }

    #	Add current directory to path so that perl programs can be found
    #	We suppose; tat user is runnig this program with
    #
    #	    % cd bin
    #	    % perl java-function-list.pl

    my $sep    = $WIN32 ? q(;)  : q(:)  ;

    @PATH = split /$sep/, $PATH;

    push @PATH, cwd();

    $ENV{PATH} = join $sep, @PATH;
    $PATH      = $ENV{PATH};

}

# }}}



# ***************************************************************** &help ****
#
#   DESCRIPTION
#
#       Print help and exit.
#
#   INPUT PARAMETERS
#
#	$msg	[optional] Reason why function was called.-
#
#   RETURN VALUES
#
#       none
#
# ****************************************************************************

=pod

=head1 NAME

@(#) java-function-list.pl - Grep all JDK/SDK Java funtions to list

=head1 SYNOPSIS

    % perl java-function-list.pl -recurse /where/is/your/jdk-root
    % perl java-function-list.pl jdk-javadoc-page/BufferedReader.html [file ..]

=head1 OPTIONS

=head2 General options

=over 4

=item B<--recurse ROOT>

Start reading HTML pages from ROOT. You can give multiple B<--root>
options to scan several root directories. The ROOT is usually your
JDK/SDK installation directory.

=back

=head2 Miscellaneous options

=over 4

=item B<--debug LEVEL>

Turn on debug with positive LEVEL number. Zero means no debug.

=item B<--help>

Print help

=item B<--test>

Run in test mode. Do now actually execute commands.

=item B<--verbose>

Turn on verbose.

=item B<--Version>

Print contact and version information

=back

=head1 README

This file is generates list of all Java methods, return values, call
parameters and thrown exections from SUN's javadoc generated pages. The
output format is as terse as possibly occupying only one line. The output
is optimized for Emacs package tinytag.el (See tiny tools project at
AVAILABILITY), which can display the information while you write Java code.

Here is example run to generate list from BufferedInputStream methods:

    % cd   java/sun/jdk1.2.2/docs/api/java/io
    % perl java-function-list.pl Buffered*Input*

    java.io.BufferedInputStream  BufferedInputStream(InputStream in)
    java.io.BufferedInputStream  BufferedInputStream(InputStream in, int size)
    java.io.BufferedInputStream  int available()  throws IOException
    java.io.BufferedInputStream protected byte[] buf
    java.io.BufferedInputStream  void close()  throws IOException
    java.io.BufferedInputStream protected int count
    java.io.BufferedInputStream  void mark(int readlimit) throws IOException
    java.io.BufferedInputStream  boolean markSupported() throws IOException
    java.io.BufferedInputStream protected int marklimit
    java.io.BufferedInputStream protected int markpos
    java.io.BufferedInputStream protected int pos
    java.io.BufferedInputStream  int read()  throws IOException
    java.io.BufferedInputStream  int read(byte[] b, int off, int len)  throws IOExce
    ption
    java.io.BufferedInputStream  void reset()  throws IOException
    java.io.BufferedInputStream  long skip(long n)  throws IOException

To generate full function and variable listing out of Java tree, use recursive
option and start from Java's root directory. You will get a very long listing.

    % perl java-function-list.pl --recurse java/sun/jdk1.2.2/docs > jdk1.2.2.lst

=head1 TROUBLESHOOTING

Please turn on --debug with level 2 to check what program really does.

=head1 EXAMPLES

No special examples.

=head1 ENVIRONMENT

No environment variables used.

=head1 FILES

No files generated.

=head1 SEE ALSO

Emacs(1) XEmacs(1) Java(1)

=head1 BUGS

There is no guarrantee that the HTML parsing gets all the definitions.
There has been no rigorous effort to check that the output has the same
information as the HTML pages.

Some Java classes inherit function from base classes and that causes some
of the the well known functions not to appear in output. This program does
not hava any intelligence to cache or refer to base class definitions. In
general, it does not now the OO relationships, it only ses the current
javadoc page being processed.

Example:

If you look at the JDK documentation page in your Java installation
sun/jdk1.2.2/docs/api/index.html --> System you will find that there is no
function print() or println() mentioned, thus they won't appear int he
generated listing. They are in fact reported in C<PrintStream> class.

    System.out.print
    System.out.println

There is nothing that can be done to this OO-inheritance other than that you
manually add the missing entries that you need to the generated files. For the
System.out, copy the java.io.PrintStream page as System.out.* functions and
you're set. Here is hand made copy which you can copy/paste to your
generated function list

    java.lang.System.out  PrintStream(OutputStream out)
    java.lang.System.out  PrintStream(OutputStream out, boolean autoFlush)
    java.lang.System.out  boolean checkError()
    java.lang.System.out  void close()
    java.lang.System.out  void flush()
    java.lang.System.out  void print(boolean b)
    java.lang.System.out  void print(Object obj)
    java.lang.System.out  void print(char c)
    java.lang.System.out  void print(int i)
    java.lang.System.out  void print(long l)
    java.lang.System.out  void print(float f)
    java.lang.System.out  void print(double d)
    java.lang.System.out  void print(char[] s)
    java.lang.System.out  void print(String s)
    java.lang.System.out  void println()
    java.lang.System.out  void println(boolean x)
    java.lang.System.out  void println(char x)
    java.lang.System.out  void println(int x)
    java.lang.System.out  void println(long x)
    java.lang.System.out  void println(float x)
    java.lang.System.out  void println(double x)
    java.lang.System.out  void println(char[] x)
    java.lang.System.out  void println(String x)
    java.lang.System.out  void println(Object x)
    java.lang.System.out  protected void setError()
    java.lang.System.out  void write(int b)
    java.lang.System.out  void write(byte[] buf, int off, int len)


=head1 AVAILABILITY

CPAN entry is
http://cpan.perl.org/modules/by-authors/id/J/JA/JARIAALTO/ Reach
author at jari.aalto@poboxes.com Tiny Tools project is at
http://tiny-tools.sourceforge.net/ where this Perl file is used in
package tinytag.el

=head1 SCRIPT CATEGORIES

CPAN/Administrative

=head1 COREQUISITES

No external CPAN modules used.

=head1 OSNAMES

C<any>

=head1 VERSION

$Id: perl-function-list.pl,v 1.1 2005-12-04 20:58:09 hute37 Exp $

=head1 AUTHOR

Copyright (C) 2000-2002 Jari Aalto. All rights reserved.
This program is free software; you can redistribute and/or modify program
under the same terms as Perl itself or in terms of Gnu General Public
licence v2 or later.

=cut

sub Help (;$)
{
    my $id  = "$LIB.Help";
    my $msg = shift;  # optional arg, why are we here...

    pod2text $PROGRAM_NAME;

    defined $msg  and  print $msg;

    exit 1;
}


# ************************************************************** &args *******
#
#   DESCRIPTION
#
#       Read and interpret command line arguments ARGV. Sets global variables
#
#   INPUT PARAMETERS
#
#	none
#
#   RETURN VALUES
#
#	none
#
# ****************************************************************************

sub HandleCommandLineArgs ()
{
    my    $id = "$LIB.HandleCommandLineArgs";

    use vars qw
    (
	$debug
	$verb
	$test
	@RECURSE
    );


    my ( $version, $help, $binary );

    # .................................................... read args ...

    Getopt::Long::config( qw
    (
	no_ignore_case
        no_ignore_case_always
        require_order
    ));

    GetOptions      # Getopt::Long
    (
	  "help"		=> \$help
	, "verbose:i"		=> \$verb
	, "Version"		=> \$version
	, "debug:i"		=> \$debug
	, "test"		=> \$test
	, "recurse=s@"		=> \@RECURSE
    );

    $version        and die "$VERSION $PROGNAME $CONTACT $URL\n";
    $help           and Help();

    $debug = 1	    if  defined $debug;
    $verb  = 1	    if  defined $verb;
    $verb  = 1	    if  $debug;
    $verb  = 1	    if  $test;

    $debug  and  warn "$id: rest command line args [@ARGV]\n";


}



# ****************************************************************************
#
#   DESCRIPTION
#
#       Expand filenames (wildcards). Win32 doesn't expand them in command line
#	as Unix does.
#
#   INPUT PARAMETERS
#
#	%	Hash data of Java HTML page. See HtmlParse()
#
#   RETURN VALUES
#
#	@	Formatted lines
#
# ****************************************************************************

sub Format ( % )
{
    my $id     = "$LIB.Format";
    my (%hash) = @ARG;


    my (@list, $class, $name, $type, $param, $ex , $str);

    for my $key ( sort keys %hash )
    {
	($class, $name, $type, $param, $ex) = @{ $hash{$key} }[0..4] ;

	# Don't include the information about public/private class memeber

	$type =~ s/public|private//ig;

	$str  = $class;

	# The sprintf choice mighht me more pleasant, but the latter is
	# mode compact fro Emaacs package tinytag.el which shows fucntion info
	#
	# $str .= sprintf " %-4s ", $type	;

	$str .= " "  . $type;

	$str .= " " . $name	if $name ne '';
	$str .= $param	        if $param ne '';

	$str .= " " . $ex	if $ex ne '';

	$str .= "\n";

	push @list, $str;
    }

    @list;
}



# ****************************************************************************
#
#   DESCRIPTION
#
#       Remove html tags
#
#   INPUT PARAMETERS
#
#	%	Hash data of Java HTMl page. See HtmlParse()
#
#   RETURN VALUES
#
#	@	Formatted lines
#
# ****************************************************************************

sub HtmlClean ( $ )
{
    my ($arg) = @ARG;

    $arg =~ s,<A\s+HREF(.*?)>,,g;
    $arg =~ s,</A>,,g;
    $arg =~ s,&[a-z]+;, ,g;
    $arg;
}


# ****************************************************************************
#
#   DESCRIPTION
#
#       Get function details out of the HTML page. This function expects
#       that the HTML is in javadoc generated format. Don't try anything else
#       but javadoc that comes with JDK 1.2.2
#
#       Removed numeric index from HASH keys if you want to use them.
#       E.g. Constructors cannot be handled otherwise because the metod
#       name is the same.
#
#   INPUT PARAMETERS
#
#	$	HTML page
#
#   RETURN VALUES
#
#	%hash	JAVA.CLASS.OBJECT
#	        => [ JAVA.CLASS, OBJECT, type, parameters, exceptions ]
#
# ****************************************************************************

sub HtmlParse ( $ ; $ )
{
    my    $id   = "$LIB.HtmlParse";
    local $ARG  = shift;
    my    $file = shift;


    # ........................................ Read class definition ...

    my $class = '';

    #     +--<B>java.io.BufferedInputStream</B>
    #     </PRE>

    if ( m,START\s+OF\s+CLASS\s+DATA.*?--<B>(.*?)</B>\s*</PRE>,si )
    {
	$class = $1;
    }

    if ( $class eq '' )
    {
	if ( $debug )
	{
	    warn "$id: ERROR Can't find standard +-- Java class definition."
		,  "$file\n"
		;
	}
	else
	{
	    $verb and warn "$id: ERROR Corrupted HTML? "
			, "Can't find Java +-- class name. $file"
			;
	}

	return;
    }


    $verb  and  warn  "$id: Extracting $file";


    # ...................................................... cleanup ...
    #	Kill until this, the method details follow after it.

    s/^.*=== FIELD DETAIL ===//si;


    # ............................................. read definitions ...

    my %hash;


    #   <!-- ============ FIELD DETAIL =========== -->
    #
    #   <A NAME="field_detail"><!-- --></A>
    #   <TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
    #   <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
    #   <TD COLSPAN=1><FONT SIZE="+2">
    #   <B>Field Detail</B></FONT></TD>
    #   </TR>
    #   </TABLE>
    #
    #   <A NAME="buf"><!-- --></A><H3>
    #   buf</H3>
    #   <PRE>
    #   protected byte[] <B>buf</B></PRE>
    #   <DL>
    #   <DD>The internal buffer array where the data is stored. When necessary,
    #    it may be replaced by another array of
    #    a different size.</DL>
    #   <HR>

    my ( $def, $qualified, $type, $name , $param, $throw , $i );

    while ( m,</H\d>\s*<PRE>\s*(.*?)</PRE>,gsi )
    {
	$def = $1;
	$def =~ s,\s\s+, ,g;

	$debug > 1  and print "$id: DEF 1 >> $def\n";


	#   Extract type and name. Here are two examples from
	#   java.io.BufferedInputStream
	#
    	#   protected byte[] <B>buf</B>
	#
	#   <PRE>
	#   public int <B>available</B>()
        #   throws <A HREF="../../java/io/IOException.html">IOException</A>
	#   </PRE>

	if ( $def =~ m,^\s*(.*\S)\s*<B>\s*(\S.*)</B>(.*),si )
	{
	    ($type, $name) = ( $1, $2 );
	    $def 	   = $3;

	    $debug > 2  and print "$id: DEF 2-0 >> TYPE $type\n";
	    $debug > 2  and print "$id: DEF 2-0 >> NAME $name\n";

	    $type = HtmlClean $type;
	    $name = HtmlClean $name;

	    $debug > 1  and print "$id: DEF 2 >> TYPE $type\n";
	    $debug > 1  and print "$id: DEF 2 >> NAME $name\n";
	    $debug > 1  and print "$id: DEF 2 >> $def\n";

	    if ( $def =~  m,(.*)(throws.*),i )
	    {
		( $param, $throw ) = ( $1, $2 );

		$throw = HtmlClean $throw;
	    }
	    else
	    {
		$param = $def;
	    }

	    #   Clean the line again
	    #   (<A HREF="../../java/io/InputStream.html">InputStream</A>&nbsp;in)

	    $param = HtmlClean $param;
	}

	$qualified = $class . "." . $name;

	unless ( exists $hash{ $qualified }  )
	{
	    $hash{ $qualified } = [$class , $name, $type, $param, $throw];
	}
	else
	{
	    $hash{ $qualified . ++$i }
	       = [$class , $name, $type, $param, $throw];
	}

	$debug and
	    warn "$id: $file MATCHED $qualified - $type - $param - $throw \n";

    }

    %hash;
}

# ****************************************************************************
#
#   DESCRIPTION
#
#       Parse one Java HTML file
#
#   INPUT PARAMETERS
#
#	$	Java html file
#
#   RETURN VALUES
#
#	@	Function listing. See HtmlParse()
#
# ****************************************************************************

sub FileParse ( $ )
{
    my $id	= "$LIB.FileParse";
    my ($file) = @ARG;

    my    $html;
    local *FILE;

    my %hash;

    if ( not -f $file )
    {
	$verb  and  warn "$id: cannot open [$file]";
    }
    else
    {
	unless ( open FILE, "< $file" )
	{
	    if ( $debug )
	    {
		$verb  and  warn "$id: open error $file $ERRNO";
	    }
	    else
	    {
		$verb  and  warn "$id: open error $file $ERRNO";
	    }
	}
	else
	{
	    $html = join "", <FILE>;
	    close FILE;
	    %hash = HtmlParse $html, $file;
	}
    }

    %hash;
}



# ****************************************************************************
#
#   DESCRIPTION
#
#       Expand filenames (wildcards). Win32 doesn't expand them in command line
#	as Unix does.
#
#   INPUT PARAMETERS
#
#	$	HTML page
#
#   RETURN VALUES
#
#	@	files
#
# ****************************************************************************

sub ExpandFiles ( @ )
{
    my $id = "$LIB.ExpandFiles";

    my (@list) = @ARG;

    #	Multiple specs can be given
    #
    #	    file* file2* f*
    #
    # 	But because the file* already inlcudes file2*, we keep %seen hash
    # 	to check if file is already included.

    my    ( %seen, @files);
    local $ARG;

    for ( @list )
    {
	#	Win32 can't expand "*". We must do it here.

	for my $file ( glob $ARG )
	{
	    unless ( exists $seen{$file} )
	    {
		push @files, $file;
		$seen{ $file } = 1;
	    }
	}
    }

    @files;
}


# ****************************************************************************
#
#   DESCRIPTION
#
#       Handle one javadoc page
#
#   INPUT PARAMETERS
#
#	$file	    Javadoc html file
#
#   RETURN VALUES
#
#	none	    prints the extracted documentation
#
# ****************************************************************************

sub FileOutput( $ )
{
    my $id 	 = "$LIB.Fileoutput";
    my ( $file ) = @ARG;

    my %hash  = FileParse $file;
    my @lines = Format %hash;

    print @lines;
}


# ****************************************************************************
#
#   DESCRIPTION
#
#       See File::Find
#
#   INPUT PARAMETERS
#
#
#
#   RETURN VALUES
#
#
#
# ****************************************************************************

#   Java JDK/SDK distribute documentation in separate package and
#   they unpack under directory docs/...
#   This flag gets set if the focs/ directory was encountered.

my $FOUND_DOCS;
my %DIRECTORY_SEEN_HASH;

sub wanted
{
    my $id = "$LIB.wanted";

    my $dir = $File::Find::dir;

    unless ( exists $DIRECTORY_SEEN_HASH{ $dir} )
    {
	$verb   and  warn  "$id: Recursing $dir\n";
	$DIRECTORY_SEEN_HASH{ $dir } = 1;
    }

    if ( $dir =~  m,/docs$, )
    {
	$FOUND_DOCS = 1;
    }

    if ( -f and -r and /\.html$/ )
    {
	$debug and print "$id: $File::Find::name\n";
	FileOutput $ARG;
    }
}

# ************************************************************** &main *******
#
#   DESCRIPTION
#
#       The start of the program
#
#   INPUT PARAMETERS
#
#	none
#
#   RETURN VALUES
#
#	none
#
# ****************************************************************************

sub Main ()
{
    Initialize();
    HandleCommandLineArgs();

    my $id  = "$LIB.Main";

    my @files = grep { -f and -r and /\.html$/ } ExpandFiles @ARGV;

    $debug  and  warn "$id: Reading HTML files [@files]";

    for my $file ( @files )
    {
	$verb  and  warn "$id: Processing file [$file]";
	FileOutput $file;
    }


    if ( defined @RECURSE  and  @RECURSE  )
    {
	$verb  and  warn "$id: Recursing .. [@RECURSE]\n";
	find ( \&wanted, @RECURSE );

	unless ( $FOUND_DOCS )
	{
	    warn "$id: Could not see Java documentation directory docs/ "
	         , "anywhere. Did you remmeber to install the Java docs from "
		 , " a separate archive? (ignore this message your doc "
		 , " directory name is different.)";

	    if ( $debug )
	    {
		warn "$id: Directories checked were:\n";

		while ( my($key) = each %DIRECTORY_SEEN_HASH )
		{
		    warn "$key\n";
		}
	    }
	}
    }

    unless ( @files or @RECURSE )
    {
	$verb and  die "$id: nothing to do. Did you forget option --recurse?";
    }

}

Main();

0;
__END__
